<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The cargo-msrv Book 🦀</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting-started/quick-start.html"><strong aria-hidden="true">2.2.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="getting-started/cargo-workspace.html"><strong aria-hidden="true">2.3.</strong> Cargo Workspace</a></li><li class="chapter-item expanded "><a href="getting-started/rust-releases-proxy.html"><strong aria-hidden="true">2.4.</strong> HTTP PROXY</a></li></ol></li><li class="chapter-item expanded "><a href="releases/index.html"><strong aria-hidden="true">3.</strong> Releases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="releases/v0.15_v0.16_highlights.html"><strong aria-hidden="true">3.1.</strong> v0.15 to v0.16</a></li><li class="chapter-item expanded "><a href="releases/v0.15_v0.16_json.html"><strong aria-hidden="true">3.2.</strong> v0.15 to v0.16 JSON</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/index.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="output-formats/index.html"><strong aria-hidden="true">5.</strong> Output Formats</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="output-formats/human.html"><strong aria-hidden="true">5.1.</strong> human</a></li><li class="chapter-item expanded "><a href="output-formats/json.html"><strong aria-hidden="true">5.2.</strong> json</a></li><li class="chapter-item expanded "><a href="output-formats/minimal.html"><strong aria-hidden="true">5.3.</strong> minimal</a></li><li class="chapter-item expanded "><a href="output-formats/no-user-output.html"><strong aria-hidden="true">5.4.</strong> no-user-output</a></li></ol></li><li class="chapter-item expanded "><a href="commands/index.html"><strong aria-hidden="true">6.</strong> Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commands/find.html"><strong aria-hidden="true">6.1.</strong> cargo-msrv find</a></li><li class="chapter-item expanded "><a href="commands/help.html"><strong aria-hidden="true">6.2.</strong> cargo-msrv help</a></li><li class="chapter-item expanded "><a href="commands/list.html"><strong aria-hidden="true">6.3.</strong> cargo-msrv list</a></li><li class="chapter-item expanded "><a href="commands/set.html"><strong aria-hidden="true">6.4.</strong> cargo-msrv set</a></li><li class="chapter-item expanded "><a href="commands/show.html"><strong aria-hidden="true">6.5.</strong> cargo-msrv show</a></li><li class="chapter-item expanded "><a href="commands/verify.html"><strong aria-hidden="true">6.6.</strong> cargo-msrv verify</a></li></ol></li><li class="chapter-item expanded "><a href="ci/index.html"><strong aria-hidden="true">7.</strong> Verification in CI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ci/gitlab.html"><strong aria-hidden="true">7.1.</strong> GitLab</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The cargo-msrv Book 🦀</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/foresterre/cargo-msrv" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-introduction"><a class="header" href="#-introduction">✨ Introduction</a></h1>
<p><code>cargo-msrv</code> is a program which can help you find, set, show or verify the MSRV for a Rust crate. You can also list the
MSRV's of dependencies.</p>
<p>MSRV stands for 'Minimum Supported Rust Version', which is exactly what it says on the tin: the earliest
Rust release which a given Rust crate promises to support. Most often support for earlier Rust versions is
limited by newly introduced Rust language features, library functions or Rust editions.</p>
<p>For example, if you want to use const generics and be generic over integers, bool's or char's, you must use a Rust
compiler which supports the const generics MVP. This feature was introduced
in <a href="https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#const-generics-mvp">Rust 1.51</a>.
If you do not have any other code, or configuration, which requires an even newer Rust release, your MSRV would
be '1.51'.</p>
<p>While the MSRV has been a well-known concept within the Rust community for a long time, it was also introduced to the
Cargo build tool and package manager, as the <code>rust-version</code>
in <a href="https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-156-2021-10-21">Cargo 1.56</a>,
which is part of the <a href="https://blog.rust-lang.org/2021/10/21/Rust-1.56.0.html#cargo-rust-version">Rust 1.56</a> release
distribution.</p>
<p>In the <a href="./commands/index.html">commands</a> section for more.</p>
<h1 id="-how-it-works"><a class="header" href="#-how-it-works">🔬 How it works</a></h1>
<p>Cargo-msrv will test your project by running various Rust toolchains against your project. The order in which the
toolchains will be tested, and the amount of tests ran, depends on the search strategy, the set of available toolchains
and of course the limiting factor of the project which will determine the MSRV. We usually call each test a
cargo-msrv <em>check</em>. By default, the check command, the command used to test whether toolchain passes or fails a check,
is <code>cargo check</code>.</p>
<p>There are currently two search strategies: <em>bisect</em> (default) and <em>linear</em>. When using the linear strategy, your crate
will be checked against toolchains from most-recent to least-recent. When a check fails, the previous Rust (if any)
version is returned as the MSRV (i.e. the highest toolchain for which a check command passes). The bisect strategy uses
a binary search to find the MSRV. This can be significantly faster, so it's usually advisable to keep it enabled by
default.</p>
<p>In addition to these two strategies, you can inspect the MSRV's set by the crate authors on which your project depends.
This is achieved by resolving the dependency graph of your crate, and querying each crate for its author specified MSRV.
Resolving the dependency graph is usually much quicker than running a toolchain command against your project, and may
give
you an indication of what your MSRV will be like. You can supply the highest listed version
as the <code>--min &lt;version&gt;</code> option: <code>cargo msrv --min &lt;version&gt;</code>. This will reduce the possible search space, and speed
up the search for the MSRV of your crate.</p>
<p>See <a href="./commands/find.html">cargo-msrv find</a> and <a href="./commands/list.html">cargo-msrv list</a> for more.</p>
<h1 id="-thanks"><a class="header" href="#-thanks">🥰 Thanks</a></h1>
<p>Thanks for using cargo-msrv! If you found an issue, or have an issue request, or any other question, feel free to open
an issue at our GitHub <a href="https://github.com/foresterre/cargo-msrv/issues">repository</a>.</p>
<p>A special thanks goes to everyone who took the time to report an issue, discuss new features and contributed to the
documentation or the code! Thank you!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-cargo-msrv"><a class="header" href="#getting-started-with-cargo-msrv">Getting started with cargo-msrv</a></h1>
<ul>
<li><a href="getting-started/installation.html">Installation</a></li>
<li><a href="getting-started/quick-start.html">Quick Start</a></li>
<li><a href="getting-started/cargo-workspace.html">Cargo Workspace</a></li>
<li><a href="getting-started/rust-releases-proxy.html">HTTP PROXY</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="-installation"><a class="header" href="#-installation">🌞 Installation</a></h2>
<p>Packages marked with 🔸 are maintained by community members (i.e. not the cargo-msrv authors). A big thank you to them!</p>
<h3 id="using-a-hrefhttpsdocrust-langorgcargocommandscargo-installhtmlcargoa"><a class="header" href="#using-a-hrefhttpsdocrust-langorgcargocommandscargo-installhtmlcargoa">Using <a href="https://doc.rust-lang.org/cargo/commands/cargo-install.html">Cargo</a>:</a></h3>
<p>You can install cargo-msrv from source by using Cargo, the Rust package manager and build tool (<a href="https://crates.io/crates/cargo-msrv">package</a>).</p>
<p><strong>How to install the latest stable release?</strong></p>
<pre><code class="language-shell">cargo install cargo-msrv
</code></pre>
<p><strong>How to install the latest stable release more quickly?</strong></p>
<p>Similar to the above, but allows for only the default channel to obtain a list of rustc releases.
This compiles about 40% faster and produces binaries about half the size in the range of 4.5MB.</p>
<pre><code class="language-shell">cargo install cargo-msrv --no-default-features
</code></pre>
<p><strong>How to install the latest development release?</strong></p>
<p>You may install <em>cargo-msrv</em> from GitHub:</p>
<pre><code class="language-shell">cargo install cargo-msrv --git https://github.com/foresterre/cargo-msrv.git --branch main
</code></pre>
<h3 id="arch-linux-"><a class="header" href="#arch-linux-">Arch Linux 🔸</a></h3>
<p>cargo-msrv is available from the Arch Linux <a href="https://archlinux.org/packages/extra/x86_64/cargo-msrv/">extra repository</a>.</p>
<p><strong>How to install?</strong></p>
<pre><code class="language-shell">pacman -S cargo-msrv
</code></pre>
<h3 id="nix-"><a class="header" href="#nix-">Nix 🔸</a></h3>
<p>cargo-msrv is available from the Nix package manager and in NixOS (<a href="https://search.nixos.org/packages?channel=21.05&amp;show=cargo-msrv&amp;from=0&amp;size=50&amp;sort=relevance&amp;type=packages&amp;query=cargo-msrv">package</a>):</p>
<p><strong>How to install (nixpkgs)?</strong></p>
<pre><code class="language-shell">nix-env -iA nixpkgs.cargo-msrv
</code></pre>
<p><strong>How to install (NixOS)?</strong></p>
<pre><code class="language-shell">nix-env -iA nixos.cargo-msrv
</code></pre>
<p>NB: When installing with <code>nix-shell --pure</code>, ensure that <code>rustup</code> is available in the environment.</p>
<h3 id="other-options"><a class="header" href="#other-options">Other options</a></h3>
<p>You may also build the program from source by cloning the <a href="https://github.com/foresterre/cargo-msrv">repository</a>
and building a release from there.</p>
<p><strong>How to build a release?</strong></p>
<pre><code class="language-shell">git clone git@github.com:foresterre/cargo-msrv.git
git checkout v0.16.0 # NB: Find the latest release tag here: https://github.com/foresterre/cargo-msrv/tags
cd cargo-msrv
cargo install cargo-msrv --path . # OR cargo build --release &amp;&amp; mv ./target/cargo-msrv ./my/install/directory
</code></pre>
<p><strong>How to build the latest development version from source?</strong></p>
<pre><code class="language-shell">git clone git@github.com:foresterre/cargo-msrv.git
cd cargo-msrv
cargo install cargo-msrv --path . # OR cargo build --release &amp;&amp; mv ./target/cargo-msrv ./my/install/directory
</code></pre>
<p>You may find additional installation options in the <a href="https://github.com/foresterre/cargo-msrv#install">README</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="-quick-start"><a class="header" href="#-quick-start">⏱️ Quick start</a></h3>
<p>If all you want to do is find the MSRV for your package, you can run:</p>
<pre><code class="language-shell">cargo msrv find
</code></pre>
<p>This command will attempt to determine the MSRV by doing a binary search on
acceptable Rust releases. If you require additional options, please refer to the
<a href="getting-started/../commands/index.html"><code>cargo-msrv commands</code></a> section, or run <code>cargo msrv help</code> to view the program's help
output.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="cargo-workspace"><a class="header" href="#cargo-workspace">Cargo Workspace</a></h3>
<p>When developing a Rust project with cargo, you may use a cargo <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html">workspace</a>
to manage a set of related packages together.</p>
<p><code>cargo-msrv</code> currently partially supports cargo workspaces although full support is on the way.</p>
<h4 id="finding-the-msrv-of-a-workspace-member"><a class="header" href="#finding-the-msrv-of-a-workspace-member">Finding the MSRV of a workspace member</a></h4>
<p>To find the MSRV of a workspace crate, you can run:</p>
<pre><code class="language-shell">cargo msrv find -- cargo check -p $crate_name
</code></pre>
<p>To verify the MSRV of a workspace, you can run:</p>
<pre><code class="language-shell">cargo msrv verify -- cargo check -p $crate_name
</code></pre>
<h4 id="workspace-support-in-cargo-msrv"><a class="header" href="#workspace-support-in-cargo-msrv">Workspace support in cargo-msrv</a></h4>
<p><code>cargo-msrv</code> should support the follow for a cargo workspace:</p>
<ul>
<li>Run <code>cargo msrv find</code> on a workspace, and find the MSRV of all, or the selected workspace packages</li>
<li>Run <code>cargo msrv find --write-msrv</code> to write the found MSRV's of the selected workspace packages</li>
<li>Run <code>cargo msrv verify</code> on a workspace, and verify the MSRV of all, or the selected workspace packages</li>
<li>Run <code>cargo msrv set --package &lt;x&gt;</code> to set the MSRV of a specific package in the workspace</li>
<li>Run <code>cargo msrv show</code> on a workspace, and present the MSRV of all, or the selected workspace packages, to the user</li>
<li>Add <code>cargo msrv --workspace</code>, <code>cargo msrv --package &lt;x&gt;</code>, <code>cargo msrv --exclude &lt;x&gt;</code> flags to select workspace packages
<ul>
<li>User selection of workspace packages was added in <a href="https://github.com/foresterre/cargo-msrv/pull/1025/files">#1025</a></li>
<li>JSON reporting of the selected workspace was added in <a href="https://github.com/foresterre/cargo-msrv/pull/1030/files">#1030</a> </li>
</ul>
</li>
<li><code>cargo msrv find</code>, <code>cargo msrv verify</code> and others should support <code>workspace.package</code> <a href="https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table">inheritance</a>, for example for:
<ul>
<li>the <code>rust-version</code> field, used by <code>cargo msrv verify</code> to detect the MSRV to verify</li>
<li>the <code>edition</code> field, used by <code>cargo msrv find</code> to restrict the search space</li>
<li>the <code>include</code> and <code>exclude</code> fields to define the workspace members</li>
</ul>
</li>
</ul>
<p>The following features are under consideration:</p>
<ul>
<li>Run <code>cargo msrv set --workspace &lt;value&gt;</code> on a workspace to set a common MSRV</li>
<li>Run <code>cargo msrv set --workspace-package &lt;x&gt;</code> to set the MSRV to the workspace.package table, if in a workspace
<ul>
<li>TODO: determine the name of the flag</li>
</ul>
</li>
<li>Run <code>cargo msrv list</code> on a workspace to list the MSRV of dependencies of each of the workspace crates.</li>
</ul>
<p>Please open an <a href="https://github.com/foresterre/cargo-msrv/issues">issue</a> if your use case is not described in the above list.</p>
<h4 id="follow-progress-on-github"><a class="header" href="#follow-progress-on-github">Follow progress on GitHub</a></h4>
<p>Tracking issue: <a href="https://github.com/foresterre/cargo-msrv/issues/1026">#1026</a></p>
<p><strong>cargo msrv find &amp; cargo msrv verify</strong></p>
<ul>
<li><a href="https://github.com/foresterre/cargo-msrv/issues/873">Add --workspace flag to subcommand find #873</a></li>
</ul>
<p><strong>cargo msrv list</strong></p>
<ul>
<li>No dedicated issue yet</li>
</ul>
<p><strong>cargo msrv set</strong></p>
<ul>
<li>No dedicated issue yet</li>
</ul>
<p><strong>cargo msrv show</strong></p>
<ul>
<li><a href="https://github.com/foresterre/cargo-msrv/issues/1024">cargo msrv show should show all workspace crate MSRV's #1024</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="rust-releases-http-proxy"><a class="header" href="#rust-releases-http-proxy">Rust Releases: HTTP PROXY</a></h3>
<p><code>cargo-msrv</code> depends on the <a href="https://github.com/foresterre/rust-releases/">rust-releases</a> crate to determine which Rust versions exist. This is a necessary evil for
the <code>cargo msrv find</code> and <code>cargo msrv verify</code> subcommands.</p>
<p>To fetch an index of known Rust releases, it accesses the network. By default, the Rust GitHub repository is used to determine
which stable releases and toolchains are available. As an alternative, this data can also be fetched from the Rust AWS S3
distribution bucket.</p>
<p>The source can be set with the <code>--release-source &lt;source&gt;</code> flag. The possible values are respectively <code>rust-changelog</code> and <code>rust-dist</code>,
for the Rust GitHub repository and the Rust AWS S3 distribution bucket. For example: <code>cargo msrv find --release-source rust-changelog</code>.</p>
<h4 id="release-source-rust-changelog"><a class="header" href="#release-source-rust-changelog">Release source: <code>rust-changelog</code></a></h4>
<p><a href="https://github.com/foresterre/rust-releases/">rust-releases</a> uses <a href="https://crates.io/crates/ureq">ureq</a> as HTTP client
for the <code>rust-changelog</code> source. From <code>cargo-msrv 0.17.1</code> (and <a href="https://github.com/foresterre/rust-releases/releases/tag/v0.29.0">rust-releases 0.29.0</a>
respectively), <code>ureq</code> has been configured to support configuring a network proxy from the environment.</p>
<p>The environment variable, <code>ureq</code> uses <a href="https://docs.rs/ureq/2.11.0/src/ureq/proxy.rs.html#87-92">are</a>:</p>
<ul>
<li><code>ALL_PROXY</code> or <code>all_proxy</code> or,</li>
<li><code>HTTPS_PROXY</code> or <code>https_proxy</code> or,</li>
<li><code>HTTP_PROXY</code> or <code>http_proxy</code></li>
</ul>
<p>The environment variable can be configured as follows:</p>
<p><code>&lt;protocol&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:port</code>, where all parts except host are optional.</p>
<p>The <code>&lt;protocol&gt;</code> must be one of: <code>http</code> (<code>socks4</code>, <code>socks4a</code> and <code>socks5</code> are currently not enabled). The default is <code>http</code>.</p>
<p>The default <code>&lt;port&gt;</code> is 80 when the <code>&lt;protocol&gt;</code> is <code>http</code> .</p>
<p>Examples: </p>
<ul>
<li><code>localhost</code></li>
<li><code>http://127.0.0.1:8080</code></li>
</ul>
<h4 id="release-source-rust-dist"><a class="header" href="#release-source-rust-dist">Release source: <code>rust-dist</code></a></h4>
<p>TODO: Not configured specifically by cargo-msrv, but could be the case.</p>
<p>The following crates are used for the <code>rust-dist</code> source:</p>
<ul>
<li><a href="https://crates.io/crates/aws-config">aws-config</a></li>
<li><a href="https://crates.io/crates/aws-sdk-s3">aws-sdk-s3</a></li>
</ul>
<p>Probably also relevant as transitive dependencies are:</p>
<ul>
<li><a href="https://crates.io/crates/aws-smithy-http">aws-smithy-http</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide"><a class="header" href="#migration-guide">Migration Guide</a></h1>
<ul>
<li><strong><a href="releases/./v0.15_v0.16_highlights.html">v0.15 to v0.16</a>: Release highlights</strong></li>
<li><strong><a href="releases/./v0.15_v0.16_json.html">v0.15 to v0.16</a>: The new JSON output format</strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="0160---a-few-release-highlights"><a class="header" href="#0160---a-few-release-highlights">0.16.0 - A few release highlights</a></h1>
<p>A quick tour through some <code>cargo msrv 0.16.0</code> highlights.</p>
<h2 id="the-noticeable-one---cargo-msrv-find"><a class="header" href="#the-noticeable-one---cargo-msrv-find">The noticeable one - cargo msrv find</a></h2>
<p>The tagline of <code>cargo-msrv</code> is &quot;Find the minimum supported Rust version (MSRV) for your project&quot;.
Previously, one could achieve this by running <code>cargo msrv</code>. If you want to do the same in 0.16, you instead
should run <code>cargo msrv find</code>. The top level  <code>cargo msrv</code> action is no more.</p>
<p>There are two primary reasons to move this action to a subcommand instead of keeping it at the top level:</p>
<ol>
<li>Consistency: <code>cargo msrv</code> can do more than that tagline, and placing all actions on the subcommand level signals that
they're equals.</li>
<li>Unsupported CLI flags and options: When actions are placed on two layers, and one of these layers is below the other,
then the bottom layer inherits its flags and options, even though they do not always overlap. For example, the set of
CLI flags and options of <code>cargo msrv find</code> and <code>cargo msrv list</code> are not identical. <code>cargo msrv find</code> for example has
an option called <code>--release-source</code> which should be present for <code>cargo msrv find</code> but not for <code>cargo msrv list</code>. If
<code>cargo msrv find</code> would still be run as <code>cargo msrv</code>, you could also invoke this option for <code>cargo msrv list</code>, like
so: <code>cargo msrv --release-source rust-dist list</code>. However, contextually, the <code>--release-source</code> option does not make
sense for <code>cargo msrv list</code>, so previously it was ignored. By making <code>cargo msrv find</code> a subcommand like
<code>cargo msrv list</code>, the flags and options which are not shared between all actions can be put solely below their own
subcommand.</li>
</ol>
<p>A consequence of (2) is that some unnecessary options and flags have been removed from the top level, and so this is a
breaking change, not just for <code>cargo msrv find</code> but also for <code>cargo msrv list</code>.</p>
<p>Minor reasons for this change include that I can now talk about <code>cargo msrv find</code> as &quot;<code>cargo msrv find</code>&quot; instead of
<code>cargo msrv (find)</code> or &quot;the top level command&quot;. Plus, it addressed some difficulties around the code which does CLI
parsing.</p>
<h2 id="the-ui-part-1-output-format-options"><a class="header" href="#the-ui-part-1-output-format-options">The UI part 1: output format options</a></h2>
<p>The way the UI is rendered has been updated. Internally, it is now easier to add and maintain different output formats.</p>
<p><code>cargo-msrv</code> now supports 3 output formats:</p>
<ul>
<li>human (the default one, intended for the human eye)</li>
<li>json (intended for machine readability)</li>
<li>minimal (*new*, it was requested for environments where people only care about success/failure, such as CI)</li>
</ul>
<h2 id="the-ui-part-2-cargo-msrv-find-and-verify-human-output"><a class="header" href="#the-ui-part-2-cargo-msrv-find-and-verify-human-output">The UI part 2: <code>cargo msrv find</code> and <code>verify</code> &quot;human&quot; output</a></h2>
<p>As they say, &quot;a picture is a thousand words&quot;:</p>
<p><strong>Previously...</strong></p>
<p><a href="https://asciinema.org/a/465459"><img src="https://asciinema.org/a/465459.svg" alt="asciicast" /></a></p>
<p><strong>New...</strong></p>
<p><a href="https://asciinema.org/a/JGyYmk7LNJvfDrc2oMQEt0SFF"><img src="https://asciinema.org/a/JGyYmk7LNJvfDrc2oMQEt0SFF.svg" alt="asciicast" /></a></p>
<p>I'll be iterating the UI further in the future. Constructive feedback is more than welcome!</p>
<h2 id="cargo-msrv-find---write-msrv"><a class="header" href="#cargo-msrv-find---write-msrv"><code>cargo msrv find --write-msrv</code></a></h2>
<p>This option will write the MSRV to your Cargo manifest:</p>
<p><a href="https://asciinema.org/a/679863?t=47"><img src="https://asciinema.org/a/679863.svg" alt="asciicast" /></a></p>
<h2 id="cargo-msrv-find---min-and---max"><a class="header" href="#cargo-msrv-find---min-and---max"><code>cargo msrv find --min</code> and <code>--max</code></a></h2>
<p>The <code>--min</code> and <code>--max</code> options would previously only take three component semver versions like &quot;1.2.3&quot; or editions. It
is common to specify the MSRV in a two component version like &quot;1.2&quot;, so these are now also supported.</p>
<h2 id="cargo-msrv-verify---rust-version"><a class="header" href="#cargo-msrv-verify---rust-version"><code>cargo msrv verify --rust-version</code></a></h2>
<p><code>cargo msrv verify</code> can be used to check whether your project is compatible with its MSRV. The MSRV is usually read from
the Cargo manifest (<code>Cargo.toml</code>). Sometimes it can be useful to provide it manually instead. That's where this option
comes in handy.</p>
<p>It should be noted that <code>cargo-msrv</code> does, at present, not unset any value you may have specified in the
Cargo manifest. So if you have a Cargo manifest with <code>rust-version = &quot;1.56.0&quot;</code> and supply the <code>--rust-version</code> option
with the value <code>1.55.0</code>, the cargo project will (if the default options are used) fail to compile, and as a consequence
<code>cargo-msrv</code> will report that your crate is not compatible with the specified MSRV.</p>
<h2 id="fetching-the-rust-releases-index"><a class="header" href="#fetching-the-rust-releases-index">Fetching the rust releases index</a></h2>
<p>The rust releases index, the thing we use to figure out which Rust versions exist, are now only fetched when a
subcommand needs it (currently <code>cargo msrv find</code> and <code>cargo msrv verify</code>).</p>
<h2 id="the-changelog"><a class="header" href="#the-changelog">The changelog</a></h2>
<p>The complete changelog can be found <a href="https://github.com/foresterre/cargo-msrv/blob/main/CHANGELOG.md">here</a>.</p>
<h2 id="thanks"><a class="header" href="#thanks">Thanks!</a></h2>
<p>Thanks to all contributors, whether you submitted a <a href="https://github.com/foresterre/cargo-msrv/pulls">PR</a> or reported
an <a href="https://github.com/foresterre/cargo-msrv/issues">issue</a>. Some reported issues and PR's really made my day! 💛</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guide-v015-to-v016-with-the-json-output-format"><a class="header" href="#migration-guide-v015-to-v016-with-the-json-output-format">Migration Guide: v0.15 to v0.16 with the JSON output format</a></h1>
<h2 id="enabling-json-output"><a class="header" href="#enabling-json-output">Enabling json output</a></h2>
<p>In v0.15, json lines output could be enabled by providing the <code>--output-format json</code> option as part of
the top level <code>cargo msrv</code> (find) command. <code>cargo msrv find --output-format json verify</code> was a valid way to specify
the output-format option, while <code>cargo msrv verify --output-format json</code> would not work (because <code>--output-format</code> was
not defined for the subcommand, <code>verify</code> in this example).</p>
<p>This is no longer required; <code>--output-format</code> is now a global option, so in the above examples, both cases will now
work.</p>
<p>NB: To determine the MSRV for a project, you should now run <code>cargo msrv find</code> instead of just <code>cargo msrv</code>. The top
level command was moved to its own subcommand for consistency and more correct CLI argument parsing.</p>
<h2 id="message-type-tag"><a class="header" href="#message-type-tag">Message type tag</a></h2>
<p>In v0.15, json messages were tagged using a field named <code>reason</code>. From v0.16 onwards, this field has been renamed
to <code>type</code> instead. Please refer to the <a href="releases/../output-formats/json.html">JSON output format</a> page for a list of supported
messages.</p>
<h2 id="message-replacements"><a class="header" href="#message-replacements">Message replacements</a></h2>
<p>In this section, we will discuss the previously supported json messages, and provide suggestions of their replacements.</p>
<h4 id="mode"><a class="header" href="#mode">Mode</a></h4>
<p>A json message with reason <code>mode</code> reported what command was running. Its direct replacement is the <code>subcommand_init</code>
message. The v0.15 <code>mode</code> message also reported about the toolchain used, and which rustup run command was used
to check for compatibility. These however are only relevant when running a command which checks for compatibility.
Since we now also have command which do not check for compatibility, such as <code>cargo msrv show</code> and <code>cargo msrv set</code>,
this was a good moment to move these fields out of this type of message. The new <code>check_method</code> message can tell you
both about the toolchain used for compatibility checks, and about the compatibility check method via its <code>method</code> field.
If this method has type <code>rustup_run</code>, then the args will contain the compatibility check arguments, previously known
as the <code>check_cmd</code>.</p>
<p>The v0.15 <code>mode</code> message consisted of:</p>
<pre><code class="language-jsonc">{
  &quot;reason&quot;: &quot;mode&quot;,
  // The mode in which cargo-msrv will operate
  &quot;mode&quot;: &quot;determine-msrv&quot; /* OR */ &quot;mode&quot;: &quot;verify-msrv&quot; /* OR */ &quot;list-msrv&quot; ,
   // The toolchain that will be used
  &quot;toolchain&quot;:&quot;x86_64-unknown-linux-gnu&quot;,
  // Command used to check a version. The key will be absent for mode 'list'
  &quot;check_cmd&quot;:&quot;cargo check&quot;
}
</code></pre>
<p>Examples of messages which replace the information reported by the v0.15 <code>mode</code> message:</p>
<pre><code class="language-json lines">...
{
  &quot;type&quot;: &quot;subcommand_init&quot;,
  &quot;subcommand_id&quot;: &quot;find&quot;
}
...
{
  &quot;type&quot;: &quot;check_method&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.38.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;method&quot;: {
    &quot;type&quot;: &quot;rustup_run&quot;,
    &quot;args&quot;: [
      &quot;1.38.0-x86_64-pc-windows-msvc&quot;,
      &quot;cargo&quot;,
      &quot;check&quot;
    ],
    &quot;path&quot;: &quot;..\\air3&quot;
  }
}
...
</code></pre>
<h4 id="installing-and-checking"><a class="header" href="#installing-and-checking">Installing and Checking</a></h4>
<p>The <code>installing</code> and <code>checking</code> messages reported respectively about locating or installing a specific Rust toolchain
and checking that toolchain for compatibility. The former has been replaced by the <code>setup_toolchain</code> event, while the
latter has been replaced by the <code>check_toolchain</code> event. Reporting about the progress has been replaced by the
<code>progress</code> event.</p>
<p>Previously, you would receive the following event:</p>
<pre><code class="language-jsonc">{
  &quot;reason&quot;: &quot;installing&quot;, /* OR */ &quot;reason&quot;: &quot;checking&quot;,
  // The current version being installed or checked
  &quot;version&quot;: &quot;1.25.0&quot;,
  // The number of versions checked before this
  &quot;step&quot;: 0,
  // The total number of versions to be checked
  &quot;total&quot;: 55,
  // The toolchain that is being used
  &quot;toolchain&quot;: &quot;x86_64-unknown-linux-gnu&quot;,
  // The command used to check each version. The key will be absent for mode 'list'
  &quot;check_cmd&quot;: &quot;cargo check&quot;
}
</code></pre>
<p>And now, you instead receive these events:</p>
<pre><code class="language-json lines">...
{
  &quot;type&quot;: &quot;progress&quot;,
  &quot;current&quot;: 25,
  &quot;search_space_size&quot;: 34,
  &quot;iteration&quot;: 2
}
...
{
  &quot;type&quot;: &quot;setup_toolchain&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.38.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;scope&quot;: {
    &quot;id&quot;: 2,
    &quot;marker&quot;: &quot;start&quot;
  }
}
{
  &quot;type&quot;: &quot;setup_toolchain&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.38.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;scope&quot;: {
    &quot;id&quot;: 2,
    &quot;marker&quot;: &quot;end&quot;
  }
}
...
{
  &quot;type&quot;: &quot;check_toolchain&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.39.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;scope&quot;: {
    &quot;id&quot;: 4,
    &quot;marker&quot;: &quot;start&quot;
  }
}
{
  &quot;type&quot;: &quot;check_toolchain&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.39.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;scope&quot;: {
    &quot;id&quot;: 4,
    &quot;marker&quot;: &quot;end&quot;
  }
}
</code></pre>
<h4 id="check-complete"><a class="header" href="#check-complete">Check complete</a></h4>
<p>The <code>check-complete</code> message would be reported when a check, which determined whether the toolchain version under test
is compatible, completed. It has been replaced by the <code>check_result</code> event. The result of the compatibility check is now
reported via the <code>is_compatible</code> field, instead of the <code>success</code> field. The progress report can be followed via the
<code>progress</code> event, and the <code>check_cmd</code> may be found by inspecting the <code>check_method</code> event, via the <code>method.args</code> field,
assuming that the <code>rustup_run</code> method (<code>method.type</code>) is used.</p>
<p>Previously, you would receive the following event:</p>
<pre><code class="language-jsonc">{
  &quot;reason&quot;: &quot;check-complete&quot;,
  // The version that was just checked
  &quot;version&quot;: &quot;1.25.0&quot;,
  // The number of versions checked before this
  &quot;step&quot;: 0,
  // The total number of versions to be checked
  &quot;total&quot;: 55,
  // true if this version is supported
  &quot;success&quot;: false,
  // The toolchain that is being used
  &quot;toolchain&quot;: &quot;x86_64-unknown-linux-gnu&quot;,
  // The command used to check each version
  &quot;check_cmd&quot;: &quot;cargo check&quot;
}
</code></pre>
<p>And now, you instead receive these events, if the toolchain is compatible:</p>
<pre><code class="language-json lines">...
{
  &quot;type&quot;: &quot;progress&quot;,
  &quot;current&quot;: 26,
  &quot;search_space_size&quot;: 34,
  &quot;iteration&quot;: 27
}
...
{
  &quot;type&quot;: &quot;check_method&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.38.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;method&quot;: {
    &quot;type&quot;: &quot;rustup_run&quot;,
    &quot;args&quot;: [
      &quot;1.38.0-x86_64-pc-windows-msvc&quot;,
      &quot;cargo&quot;,
      &quot;check&quot;
    ],
    &quot;path&quot;: &quot;..\\air3&quot;
  }
}
...
{
  &quot;type&quot;: &quot;check_result&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.38.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;is_compatible&quot;: true
}
</code></pre>
<p>Or, if the toolchain is deemed incompatible:</p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;progress&quot;,
  &quot;current&quot;: 27,
  &quot;search_space_size&quot;: 34,
  &quot;iteration&quot;: 28
}
...
{
  &quot;type&quot;: &quot;check_method&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.37.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;method&quot;: {
    &quot;type&quot;: &quot;rustup_run&quot;,
    &quot;args&quot;: [
      &quot;1.37.0-x86_64-pc-windows-msvc&quot;,
      &quot;cargo&quot;,
      &quot;check&quot;
    ],
    &quot;path&quot;: &quot;..\\air3&quot;
  }
}
...
{
  &quot;type&quot;: &quot;check_result&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.37.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;is_compatible&quot;: false,
  &quot;error&quot;: &quot;error: failed to parse lock file at: ..\\air3\\Cargo.lock\n\nCaused by:\n  invalid serialized PackageId for key `package.dependencies`\n&quot;
}
</code></pre>
<h4 id="msrv-completed"><a class="header" href="#msrv-completed">MSRV completed</a></h4>
<p>When the find msrv command or the verify command would be completed, they would report about their result.
The success field would respectively be used to report whether an MSRV had been found, or whether the MSRV being
verified
was compatible or not. These messages, <code>msrv-complete</code> and <code>verify-complete</code> have been replaced by the
<code>subcommand_result</code>
event. Please refer to the <a href="releases/../output-formats/json.html#event-subcommandresult">subcommand_result</a> event for the complete
description of output per command.</p>
<p>The v0.15 output had the following format:</p>
<pre><code class="language-jsonc">{
  &quot;reason&quot;: &quot;msrv-complete&quot; /* OR */ &quot;reason&quot;: &quot;verify-complete&quot;,
  // true if a msrv was found
  &quot;success&quot;: true,
  // the msrv if found. The key will be absent if msrv wasn't found
  &quot;msrv&quot;: &quot;1.42.0&quot;,
  // The toolchain that is being used
  &quot;toolchain&quot;: &quot;x86_64-unknown-linux-gnu&quot;,
  // The command used to check each version. The key will be absent for mode 'list'
  &quot;check_cmd&quot;: &quot;cargo check&quot;
}
</code></pre>
<p>Below, you can find an example of the new output when finding the MSRV, where one is found:</p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;find&quot;,
  &quot;result&quot;: {
    &quot;version&quot;: &quot;1.38.0&quot;,
    &quot;success&quot;: true
  }
}
</code></pre>
<p>And another example for the output of the verify command, where the verification failed:</p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;verify&quot;,
  &quot;result&quot;: {
    &quot;toolchain&quot;: {
      &quot;version&quot;: &quot;1.60.0&quot;,
      &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
    },
    &quot;is_compatible&quot;: false,
    &quot;error&quot;: &quot;    Checking air v0.0.0 (..\\air)\nerror: expected one of `:`, `&lt;`, `=`, `where`, or `{`, found `&lt;eof&gt;`\n  --&gt; src\\lib.rs:24:11\n   |\n24 | pub trait DisplayEvent\n   |           ^^^^^^^^^^^^ expected one of `:`, `&lt;`, `=`, `where`, or `{`\n\nerror: could not compile `air` due to previous error\n&quot;
  }
}
</code></pre>
<h4 id="list-msrvs-specified-by-crate-authors"><a class="header" href="#list-msrvs-specified-by-crate-authors">List MSRV's specified by crate authors</a></h4>
<p>This event contains the output of the list command, which reports the MSRV of dependencies of a crate.
The exact output depends on which variant is used, either <code>ordered-by-msrv</code> (default) or <code>direct-deps</code>.</p>
<p>The output of the list command is almost the same as it was before. The event is no longer called <code>list</code>; instead
the output is given via the <code>subcommand_result</code> event, where the value of <code>subcommand_id</code> is <code>list</code>. The output of the
command (<code>variant</code> and <code>list</code> fields) can now be found as part of the <code>result</code> field. The <code>success</code> field has been
removed.</p>
<pre><code class="language-jsonc">{
  &quot;reason&quot;: &quot;list&quot;,
  // output variant
  &quot;variant&quot;: &quot;ordered-by-msrv&quot; /* OR */ &quot;direct-deps&quot;,
  // always success when returning a result
  &quot;success&quot;: true,
  // The output of the list subcommand
  &quot;list&quot;: [
    /* when variant = 'ordered-by-msrv */
    {
        &quot;msrv&quot;: &quot;&lt;msrv&gt;&quot;,
        &quot;dependencies&quot;: [&quot;&lt;dependencies which have this msrv&gt;&quot;, ...]
    }
    /* OR, when variant = direct-deps */
    {
        &quot;dependency&quot;: &quot;&lt;dependency crate name&gt;&quot;,
        &quot;version&quot;: &quot;&lt;dependency crate version&gt;&quot;,
        &quot;msrv&quot;: &quot;&lt;dependency crate msrv&gt;&quot;,
        &quot;depends_on&quot;: [&quot;&lt;dependencies of direct dependency crate&gt;&quot;, ...]
    }
  ],
}
</code></pre>
<p>An example of the <code>ordered-by-msrv</code> variant:</p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;list&quot;,
  &quot;result&quot;: {
    &quot;variant&quot;: &quot;ordered-by-msrv&quot;,
    &quot;list&quot;: [
      {
        &quot;msrv&quot;: &quot;1.38.0&quot;,
        &quot;dependencies&quot;: [
          &quot;storyteller&quot;
        ]
      },
      {
        &quot;msrv&quot;: &quot;1.36.0&quot;,
        &quot;dependencies&quot;: [
          &quot;crossbeam-channel&quot;,
          &quot;crossbeam-utils&quot;
        ]
      },
      {
        &quot;msrv&quot;: null,
        &quot;dependencies&quot;: [
          &quot;cfg-if&quot;,
          &quot;lazy_static&quot;
        ]
      }
    ]
  }
}
</code></pre>
<p>An example of the <code>direct-deps</code> variant:</p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;list&quot;,
  &quot;result&quot;: {
    &quot;variant&quot;: &quot;direct-deps&quot;,
    &quot;list&quot;: [
      {
        &quot;name&quot;: &quot;crossbeam-channel&quot;,
        &quot;version&quot;: &quot;0.5.4&quot;,
        &quot;msrv&quot;: &quot;1.36.0&quot;,
        &quot;dependencies&quot;: [
          &quot;cfg-if&quot;,
          &quot;crossbeam-utils&quot;,
          &quot;num_cpus&quot;,
          &quot;rand&quot;,
          &quot;signal-hook&quot;
        ]
      }
    ]
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>🚧 Section is work-in-progress.</p>
<h1 id="-concepts"><a class="header" href="#-concepts">🌱 Concepts</a></h1>
<h2 id="rust-releases-index"><a class="header" href="#rust-releases-index">Rust Releases Index</a></h2>
<h3 id="release-source"><a class="header" href="#release-source">Release Source</a></h3>
<ul>
<li>rust-changelog (default)</li>
<li>rust-dist</li>
</ul>
<h2 id="resolver"><a class="header" href="#resolver">Resolver</a></h2>
<ul>
<li>run-toolchain resolver (default): resolver which runs actual toolchains against a crate</li>
<li>rust-version resolver: author defined resolver, used by <code>cargo-msrv list</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-formats"><a class="header" href="#output-formats">Output formats</a></h1>
<p>In <code>cargo-msrv</code> we to status of the program is reported via events. These events are issued at several stages of the
program execution. As a user of <code>cargo-msrv</code>, you may choose how these events are formatted into a human-readable
or machine-readable representation. User output may also be disabled altogether.</p>
<p>The next section gives an overview of the supported representations. Thereafter, you may find an index to
the chapters which detail each representation.</p>
<h2 id="choosing-an-output-format"><a class="header" href="#choosing-an-output-format">Choosing an output format</a></h2>
<p>The first output format is the <code>human</code> output format. As the name suggests,
its output is meant to be interpreted by humans, and consists of elaborate colouring and
custom styling.</p>
<p>The second output format is the <code>json</code> output format. This is a detailed machine-readable
format and also the format which most closely mimics the events as they are reported internally.
Events are printed in a <code>json-lines</code> (<code>jsonl</code>) format to <em>stderr</em>.</p>
<p>The third output-format is the <code>minimal</code> output format. This format is intended to be used by shell scripts
or programs which do not require detailed output. Its format does not require complex parsing, and only
reports the final results of commands.</p>
<p>The fourth option is to not print any user output. This is uncommon, but may be used in conjunction with
printing debug (i.e. developer) output only, so the debug output is not overwritten by the user output.</p>
<h2 id="the-output-formats"><a class="header" href="#the-output-formats">The output formats</a></h2>
<ul>
<li><a href="output-formats/human.html">human</a> (default)</li>
<li><a href="output-formats/json.html">json</a></li>
<li><a href="output-formats/minimal.html">minimal</a></li>
<li><a href="output-formats/no-user-output.html">no-user-output</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-format-human"><a class="header" href="#output-format-human">Output format: human</a></h1>
<p>This is the default output format. It can also be specified using the <code>--output-format human</code> option.</p>
<p>The output of the 'human' output format is intended to be interpreted by humans. It uses colour and custom printed
layouts to convey its information to the user.</p>
<p>In the next section, examples are given for each subcommand and a specific use case. You may run <code>cargo msrv help</code> to
review all flags and options available.</p>
<h1 id="output-by-subcommand"><a class="header" href="#output-by-subcommand">Output by subcommand</a></h1>
<h2 id="cargo-msrv-find"><a class="header" href="#cargo-msrv-find"># cargo msrv (find)</a></h2>
<p><strong>I want to find the MSRV of my project</strong></p>
<p>Use: <code>cargo msrv</code></p>
<p><a href="https://asciinema.org/a/530521"><img src="https://asciinema.org/a/530521.svg" alt="Screencast: find the MSRV" /></a></p>
<p>The output shows for each checked toolchain whether it is determined to be compatible or not.
If a toolchain is not compatible, a reason is printed which may help you discover why it is not deemed compatible.</p>
<p>cargo-msrv will show a summary after the search completes. The summary consists of the search space considered,
the search method used, the compiler target and of course the MSRV.</p>
<p>It is also possible that no MSRV could be found, for example if the program is not valid Rust code (i.e. would not
compile).</p>
<p><strong>I want to find the MSRV and write the result to the Cargo manifest</strong></p>
<p>Use the <code>--write-msrv</code> flag: <code>cargo msrv find --write-msrv</code></p>
<p><a href="https://asciinema.org/a/530521"><img src="https://asciinema.org/a/530521.svg" alt="Screencast: find the MSRV and write the result to the Cargo manifest" /></a></p>
<p>The output is the same as for <code>cargo msrv</code>, plus an additional message which states that the MSRV has been written to
the Cargo manifest.</p>
<p><em>Support for also writing to the clippy config is tracked in
<a href="https://github.com/foresterre/cargo-msrv/issues/529">issue 529</a></em>.</p>
<p><strong>I want to find the MSRV and limit or increase the search space</strong></p>
<p>Use the <code>--min</code> and/or <code>--max</code> options: <code>cargo msrv find --min &lt;Rust version or edition&gt; --max &lt;Rust version&gt;</code></p>
<p><a href="https://asciinema.org/a/SEqHCRxI5xe0eizaBbIraHZcV"><img src="https://asciinema.org/a/SEqHCRxI5xe0eizaBbIraHZcV.svg" alt="Sceencast: find the MSRV with a customized search space" /></a></p>
<p>By default, the search space is limited by the edition specified in the Cargo manifest. You may use the above
options to override the limits of the search space. The output will be the same as otherwise running <code>cargo msrv</code>.</p>
<p>In the example we specified the minimal version by specifying a Rust edition. We also could've specified a Rust version
instead, e.g. <code>1.10</code> or <code>1.20.0</code>. It is not possible for the maximum considered version to specify an edition.</p>
<p><strong>I want to find the MSRV, but use a linear search</strong></p>
<p>Use the <code>--linear</code> flag: <code>cargo msrv find --linear</code></p>
<p><a href="https://asciinema.org/a/530645"><img src="https://asciinema.org/a/530645.svg" alt="Screencast: find the MSRV using a linear search" /></a></p>
<p>We use the bisection search method to speed up the search for the MSRV considerably, but sometimes a linear search
can be useful, for example if the search space is very small. The output will be the same as otherwise running
<code>cargo msrv</code>, except of course for the order in which the search is performed.</p>
<h2 id="cargo-msrv-list"><a class="header" href="#cargo-msrv-list"># cargo msrv list</a></h2>
<p><strong>I want to list the MSRV's of all dependencies</strong></p>
<p>Use: <code>cargo msrv list</code></p>
<p><a href="https://asciinema.org/a/530652"><img src="https://asciinema.org/a/530652.svg" alt="Screencast: list MSRV's of dependencies" /></a></p>
<p>This example shows how to list the MSRV's of dependencies. The MSRV's are sourced from their Cargo manifests.</p>
<p><strong>I want to list the MSRV's of my direct dependencies</strong></p>
<p>Use the <code>--variant</code> option: <code>cargo msrv list --variant direct-deps</code></p>
<p><a href="https://asciinema.org/a/AU2Xaq1hrXUYfjLdUvDzZHaCC"><img src="https://asciinema.org/a/AU2Xaq1hrXUYfjLdUvDzZHaCC.svg" alt="Screencast: list MSRV's of direct dependencies" /></a></p>
<p>In this example, we instead list the MSRV's of the dependencies specified in the Cargo manifest.</p>
<h2 id="cargo-msrv-set"><a class="header" href="#cargo-msrv-set"># cargo msrv set</a></h2>
<p><strong>I want to set or update the MSRV of my project</strong></p>
<p>Use: <code>cargo msrv set &lt;version&gt;</code></p>
<p><a href="https://asciinema.org/a/530670"><img src="https://asciinema.org/a/530670.svg" alt="asciicast" /></a></p>
<h2 id="cargo-msrv-show"><a class="header" href="#cargo-msrv-show"># cargo msrv show</a></h2>
<h2 id="cargo-msrv-verify"><a class="header" href="#cargo-msrv-verify"># cargo msrv verify</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-format-json"><a class="header" href="#output-format-json">Output format: json</a></h1>
<p>The <code>json</code> output format is intended to be used as a machine-readable output, to be interpreted by tooling, although
humans may also use it, as it provides the most detailed output of all supported output formats.</p>
<p>As described on the <a href="output-formats/index.html">output-formats</a> page, <code>cargo-msrv</code> reports the status of the program via
events. A processor transforms these events into their output-format. In case of the <code>json</code> output format,
events are almost 1-on-1 serialized to json (there are a few exceptions), and then printed to <code>stderr</code>.
Each json serialized event ends with a newline. Each line thus represents a single serialized event.</p>
<p>To use the <code>json</code> output format, run <code>cargo-msrv</code> with the <code>--output-format json</code> option.
For example, if you want to find the MSRV, you could run <code>cargo msrv find --output-format json</code>.</p>
<p>In the next section, you can find a description of the common fields of events.
The section thereafter gives an overview of each of the supported events, with for each event its event specific fields.</p>
<h1 id="events-and-scope"><a class="header" href="#events-and-scope">Events and scope</a></h1>
<p>Cargo MSRV currently reports two types of events: unscoped and scoped events. Unscoped events report about an action
on a certain point in time, while scoped events report about an action which took place over a period of time.</p>
<p>In the context of the <code>json</code> output format, an unscoped event will print a single json-line to the stderr, while
a scoped event will print two json-lines to the stderr (one prior to starting the action, and one after the action has
been completed).</p>
<h1 id="common-fields-on-events"><a class="header" href="#common-fields-on-events">Common fields on events</a></h1>
<table><thead><tr><th>name</th><th>optional</th><th>values</th><th>description</th></tr></thead><tbody>
<tr><td>type</td><td>no</td><td></td><td>Identifies a specific event.</td></tr>
<tr><td>scope</td><td>yes</td><td></td><td>A pair of events which mark the start and end of an action. Together these two individual events are called a scoped event.</td></tr>
<tr><td>scope.id</td><td>no</td><td></td><td>A unique id to match up the two events marking the begin and end of an action. The current incremental nature is an implementation detail and not guaranteed.</td></tr>
<tr><td>scope.marker</td><td>no</td><td>&quot;start&quot; or &quot;end&quot;</td><td>Whether the event marks the beginning or the end of the action</td></tr>
</tbody></table>
<p>The <strong>type</strong> field can be used to identify a specific event.</p>
<p>The <strong>scope</strong> field is only present for scoped events. The <code>start</code> value (on the <code>marker</code> subfield) marks the start of a
scoped event, while <code>end</code>
marks the end of a scoped event.</p>
<h1 id="list-of-events"><a class="header" href="#list-of-events">List of events</a></h1>
<h2 id="event-meta"><a class="header" href="#event-meta">Event: <code>Meta</code></a></h2>
<p><strong>type:</strong> meta</p>
<p><strong>description:</strong> Reports metadata about the currently running <code>cargo-msrv</code> program instance.</p>
<p><strong>fields:</strong></p>
<table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>instance</td><td>Name of the running <code>cargo-msrv</code> program as defined on compile time. This will usually be <code>cargo-msrv</code>.</td></tr>
<tr><td>version</td><td>Version of the running <code>cargo-msrv</code> program as defined on compile time.</td></tr>
<tr><td>sha_short</td><td>Short SHA hash of the git commit used to compile and build <code>cargo-msrv</code>.</td></tr>
<tr><td>target_triple</td><td>Target triple of toolchain used to compile and build <code>cargo-msrv</code>.</td></tr>
<tr><td>cargo_features</td><td>Features which were enabled during the compilation of <code>cargo-msrv</code>.</td></tr>
<tr><td>rustc</td><td>Version of <code>rustc</code> used to compile <code>cargo-msrv</code>.</td></tr>
</tbody></table>
<p><strong>example:</strong></p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;meta&quot;,
  &quot;instance&quot;: &quot;cargo-msrv&quot;,
  &quot;version&quot;: &quot;0.15.1&quot;,
  &quot;sha_short&quot;: &quot;79582b6&quot;,
  &quot;target_triple&quot;: &quot;x86_64-pc-windows-msvc&quot;,
  &quot;cargo_features&quot;: &quot;default,rust_releases_dist_source&quot;,
  &quot;rustc&quot;: &quot;1.62.0&quot;
}
</code></pre>
<h2 id="event-fetchindex"><a class="header" href="#event-fetchindex">Event: <code>FetchIndex</code></a></h2>
<p><strong>type:</strong> fetch_index</p>
<p><strong>description:</strong> Prior to determining the MSRV of a crate, we have to figure out which Rust versions are available.
We obtain those using the <a href="https://crates.io/crates/rust-releases">rust-releases</a> library. The <code>FetchIndex</code> event
reports that the index is being fetched, and details which source is used.</p>
<p><strong>fields:</strong></p>
<table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>source</td><td>Place from where the available Rust releases are obtained</td></tr>
</tbody></table>
<p><strong>example:</strong></p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;fetch_index&quot;,
  &quot;source&quot;: &quot;rust_changelog&quot;,
  &quot;scope&quot;: &quot;start&quot;
}
{
  &quot;type&quot;: &quot;fetch_index&quot;,
  &quot;source&quot;: &quot;rust_changelog&quot;,
  &quot;scope&quot;: &quot;end&quot;
}
</code></pre>
<h2 id="event-checktoolchain"><a class="header" href="#event-checktoolchain">Event: <code>CheckToolchain</code></a></h2>
<p><strong>type:</strong> check_toolchain</p>
<p><strong>description:</strong> The primary way for <code>cargo-msrv</code> to determine whether a given Rust toolchain is compatible with your
crate, is by installing a toolchain and using it to check a crate for compatibility with this toolchain. The
<code>CheckToolchain</code> event is wrapped around this process and notifies you about the start and end of this process.
This event is called as a scoped event, and within it's scope, you'll find the following events: <code>setup_toolchain</code>,
<code>check_method</code> and <code>check_result</code>, which are described in more detail below.</p>
<p><strong>fields:</strong></p>
<table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>toolchain</td><td>The toolchain to be located or installed</td></tr>
<tr><td>toolchain.version</td><td>The Rust version of the toolchain</td></tr>
<tr><td>toolchain.target</td><td>The target-triple of the toolchain</td></tr>
</tbody></table>
<p><strong>example:</strong></p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;check_toolchain&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.35.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;scope&quot;: &quot;start&quot;
}
{
  &quot;type&quot;: &quot;check_toolchain&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.35.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;scope&quot;: &quot;end&quot;
}
</code></pre>
<h2 id="event-setuptoolchain"><a class="header" href="#event-setuptoolchain">Event: <code>SetupToolchain</code></a></h2>
<p><strong>type:</strong> setup_toolchain</p>
<p><strong>description:</strong> The primary way for <code>cargo-msrv</code> to determine whether a given Rust toolchain is compatible with your
crate, is by installing a toolchain and using it to check a crate for compatibility with this toolchain. The
<code>SetupToolchain</code> event reports about the process of locating or installing a given toolchain.</p>
<p><strong>fields:</strong></p>
<table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>toolchain</td><td>The toolchain to be located or installed</td></tr>
<tr><td>toolchain.version</td><td>The Rust version of the toolchain</td></tr>
<tr><td>toolchain.target</td><td>The target-triple of the toolchain</td></tr>
</tbody></table>
<p><strong>example:</strong></p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;setup_toolchain&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.47.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;scope&quot;: &quot;start&quot;
}
{
  &quot;type&quot;: &quot;setup_toolchain&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.47.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;scope&quot;: &quot;end&quot;
}
</code></pre>
<h2 id="event-checkmethod"><a class="header" href="#event-checkmethod">Event: <code>CheckMethod</code></a></h2>
<p><strong>type:</strong> check_method</p>
<p><strong>description:</strong> Reports which method has been used to check whether a toolchain is compatible with a crate.</p>
<p><strong>fields:</strong></p>
<table><thead><tr><th>name</th><th>optional</th><th>condition</th><th>description</th></tr></thead><tbody>
<tr><td>toolchain</td><td>no</td><td></td><td>The toolchain to be located or installed</td></tr>
<tr><td>toolchain.version</td><td>no</td><td></td><td>The Rust version of the toolchain</td></tr>
<tr><td>toolchain.target</td><td>no</td><td></td><td>The target-triple of the toolchain</td></tr>
<tr><td>method</td><td>no</td><td></td><td>The method used to check for compatibility</td></tr>
<tr><td>method.type</td><td>no</td><td></td><td>The type of method</td></tr>
<tr><td>method.args</td><td>no</td><td>method.type = <code>rustup_run</code></td><td>The arguments provided to rustup</td></tr>
<tr><td>method.path</td><td>yes</td><td>method.type = <code>rustup_run</code></td><td>The path provided to rustup, if any</td></tr>
</tbody></table>
<p><strong>example:</strong></p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;check_method&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.37.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;method&quot;: {
    &quot;rustup_run&quot;: {
      &quot;args&quot;: [
        &quot;1.37.0-x86_64-pc-windows-msvc&quot;,
        &quot;cargo&quot;,
        &quot;check&quot;
      ],
      &quot;path&quot;: &quot;..\\air3\\&quot;
    }
  }
}
</code></pre>
<h2 id="event-checkresult"><a class="header" href="#event-checkresult">Event: <code>CheckResult</code></a></h2>
<p><strong>type:</strong> check_result</p>
<p><strong>description:</strong> Reports the result of a <code>cargo-msrv</code> compatibility check.</p>
<p><strong>fields:</strong></p>
<table><thead><tr><th>name</th><th>optional</th><th>condition</th><th>description</th></tr></thead><tbody>
<tr><td>toolchain</td><td>no</td><td></td><td>The toolchain to be located or installed</td></tr>
<tr><td>toolchain.version</td><td>no</td><td></td><td>The Rust version of the toolchain</td></tr>
<tr><td>toolchain.target</td><td>no</td><td></td><td>The target-triple of the toolchain</td></tr>
<tr><td>is_compatible</td><td>no</td><td></td><td>Boolean value stating compatibility</td></tr>
<tr><td>error</td><td>yes</td><td>is_compatible = <code>false</code></td><td>Error message of a failed compatibility check, if any</td></tr>
</tbody></table>
<p><strong>example:</strong></p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;check_result&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.38.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;is_compatible&quot;: true
}
</code></pre>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;check_result&quot;,
  &quot;toolchain&quot;: {
    &quot;version&quot;: &quot;1.37.0&quot;,
    &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
  },
  &quot;is_compatible&quot;: false,
  &quot;error&quot;: &quot;error: failed to parse lock file at: .\\air3\\Cargo.lock\n\nCaused by:\ninvalid serialized PackageId for key `package.dependencies`\n&quot;
}
</code></pre>
<h2 id="event-auxiliaryoutput"><a class="header" href="#event-auxiliaryoutput">Event: <code>AuxiliaryOutput</code></a></h2>
<p><strong>type:</strong> auxiliary_output</p>
<p><strong>description:</strong> Reports about additional output written by <code>cargo-msrv</code> when applicable. For example, if the
<code>--write-msrv</code> or <code>--write-toolchain-file</code> flag is provided, the MSRV will be written to the Cargo manifest or the
Rust toolchain file respectively. The act of writing this (additional) output is reported by this event.</p>
<p><strong>fields:</strong></p>
<table><thead><tr><th>name</th><th>optional</th><th>condition</th><th>description</th></tr></thead><tbody>
<tr><td>destination</td><td>no</td><td></td><td>The destination of the auxiliary output</td></tr>
<tr><td>destination.type</td><td>no</td><td></td><td>Type of destination, currently only &quot;file&quot;</td></tr>
<tr><td>destination.path</td><td>no</td><td>if destination.type = <code>file</code></td><td>Path of the written or amended file</td></tr>
<tr><td>item</td><td>no</td><td></td><td>What kind of output is written</td></tr>
<tr><td>item.type</td><td>no</td><td></td><td>Type of output item</td></tr>
<tr><td>item.kind</td><td>no</td><td>if item.type = <code>msrv</code></td><td>To which field the MSRV was written in the Cargo manifest, &quot;rust-version&quot; or &quot;metadata_fallback&quot;</td></tr>
<tr><td>item.kind</td><td>no</td><td>if item.type = <code>toolchain_file</code></td><td>Which toolchain file kind was written, &quot;legacy&quot; or &quot;toml&quot;</td></tr>
</tbody></table>
<p><strong>example:</strong></p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;auxiliary_output&quot;,
  &quot;destination&quot;: {
    &quot;type&quot;: &quot;file&quot;,
    &quot;path&quot;: &quot;..\\air3\\Cargo.toml&quot;
  },
  &quot;item&quot;: {
    &quot;type&quot;: &quot;msrv&quot;,
    &quot;kind&quot;: &quot;rust_version&quot;
  }
}
</code></pre>
<h2 id="event-progress"><a class="header" href="#event-progress">Event: <code>Progress</code></a></h2>
<p><strong>type:</strong> progress</p>
<p><strong>description:</strong> Reports on the progress of an ongoing MSRV search.</p>
<p><strong>fields:</strong></p>
<table><thead><tr><th>name</th><th>optional</th><th>condition</th><th>description</th></tr></thead><tbody>
<tr><td>current</td><td>no</td><td></td><td>Index of the currently running check into the sorted search space. Starts at <code>0</code>.</td></tr>
<tr><td>search_space_size</td><td>no</td><td></td><td>The size of the search space.</td></tr>
<tr><td>iteration</td><td>no</td><td></td><td>How many iterations have been completed, plus one for the currently running iteration. Starts at <code>1</code>.</td></tr>
</tbody></table>
<!-- Future: add length of reduced set size -->
<h2 id="event-subcommandinit"><a class="header" href="#event-subcommandinit">Event: <code>SubcommandInit</code></a></h2>
<p><strong>type:</strong> subcommand_init</p>
<p><strong>description:</strong> Reports the start of a subcommand flow.</p>
<p><strong>fields:</strong></p>
<table><thead><tr><th>name</th><th>optional</th><th>condition</th><th>description</th></tr></thead><tbody>
<tr><td>subcommand_id</td><td>no</td><td></td><td>A name identifying the subcommand</td></tr>
</tbody></table>
<h2 id="event-subcommandresult"><a class="header" href="#event-subcommandresult">Event: <code>SubcommandResult</code></a></h2>
<p><strong>type:</strong> subcommand_result</p>
<p><strong>description:</strong> Reports the outcome of a subcommand flow.</p>
<p><strong>fields:</strong></p>
<table><thead><tr><th>name</th><th>optional</th><th>condition</th><th>description</th></tr></thead><tbody>
<tr><td>subcommand_id</td><td>no</td><td></td><td>A name identifying the subcommand</td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
<tr><td>result</td><td>no</td><td>subcommand_id = <code>find</code></td><td>Result of find command</td></tr>
<tr><td>result.success</td><td>no</td><td>subcommand_id = <code>find</code></td><td>Whether the MSRV was found or not</td></tr>
<tr><td>result.version</td><td>no</td><td>subcommand_id = <code>find</code> and result.success = <code>true</code></td><td>The Minimum Supported Rust Version (MSRV)</td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
<tr><td>result</td><td>no</td><td>subcommand_id = <code>list</code></td><td>Result of list command</td></tr>
<tr><td>result.variant</td><td>no</td><td>subcommand_id = <code>list</code></td><td>Type of list output. Either <code>direct-deps</code> or <code>ordered-by-msrv</code>.</td></tr>
<tr><td>result.list</td><td>no</td><td>subcommand_id = <code>list</code> and result.variant = <code>direct-deps</code></td><td>List of direct dependencies of the selected crate</td></tr>
<tr><td>result.list.name</td><td>no</td><td>subcommand_id = <code>list</code> and result.variant = <code>direct-deps</code></td><td>Name of the crate</td></tr>
<tr><td>result.list.version</td><td>no</td><td>subcommand_id = <code>list</code> and result.variant = <code>direct-deps</code></td><td>Version of the crate</td></tr>
<tr><td>result.list.msrv</td><td>no</td><td>subcommand_id = <code>list</code> and result.variant = <code>direct-deps</code></td><td>MSRV of the crate if any, <code>null</code> if the MSRV is not set</td></tr>
<tr><td>result.list.dependencies</td><td>no</td><td>subcommand_id = <code>list</code> and result.variant = <code>direct-deps</code></td><td>Dependencies of the given crate, relevant for the MSRV</td></tr>
<tr><td>result.list</td><td>no</td><td>subcommand_id = <code>list</code> and result.variant = <code>ordered-by-msrv</code></td><td>List of all dependencies relevant for the MSRV, categorised by their MSRV</td></tr>
<tr><td>result.list.msrv</td><td>no</td><td>subcommand_id = <code>list</code> and result.variant = <code>ordered-by-msrv</code></td><td>A value for the MSRV specified by at least one crate</td></tr>
<tr><td>result.list.dependencies</td><td>no</td><td>subcommand_id = <code>list</code> and result.variant = <code>ordered-by-msrv</code></td><td>List of dependencies which specified the same value for the MSRV</td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
<tr><td>result</td><td>no</td><td>subcommand_id = <code>set</code></td><td>Result of set command</td></tr>
<tr><td>result.version</td><td>no</td><td>subcommand_id = <code>set</code></td><td>Which version was set as MSRV</td></tr>
<tr><td>result.manifest_path</td><td>no</td><td>subcommand_id = <code>set</code></td><td>Relative path of file where the MSRV was written to</td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
<tr><td>result</td><td>no</td><td>subcommand_id = <code>show</code></td><td>Result of show command</td></tr>
<tr><td>result.version</td><td>no</td><td>subcommand_id = <code>show</code></td><td>MSRV as set for the given crate</td></tr>
<tr><td>result.manifest_path</td><td>no</td><td>subcommand_id = <code>show</code></td><td>Relative path of file where the MSRV was read from</td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
<tr><td>result</td><td>no</td><td>subcommand_id = <code>verify</code></td><td>Result of verify command</td></tr>
<tr><td>result.toolchain</td><td>no</td><td>subcommand_id = <code>verify</code></td><td>The toolchain to be located or installed</td></tr>
<tr><td>result.toolchain.version</td><td>no</td><td>subcommand_id = <code>verify</code></td><td>The Rust version of the verified toolchain</td></tr>
<tr><td>result.toolchain.target</td><td>no</td><td>subcommand_id = <code>verify</code></td><td>The target-triple of the verified toolchain</td></tr>
<tr><td>result.is_compatible</td><td>no</td><td>subcommand_id = <code>verify</code></td><td>Boolean value stating compatibility</td></tr>
<tr><td>result.error</td><td>yes</td><td>subcommand_id = <code>verify</code> and result.is_compatible = <code>false</code></td><td>Error message of a failed verify check, if any</td></tr>
</tbody></table>
<p><strong>example 1: find</strong></p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;find&quot;,
  &quot;result&quot;: {
    &quot;version&quot;: &quot;1.38.0&quot;,
    &quot;success&quot;: true
  }
}
</code></pre>
<p><strong>example 2: list with direct-deps</strong></p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;list&quot;,
  &quot;result&quot;: {
    &quot;variant&quot;: &quot;direct-deps&quot;,
    &quot;list&quot;: [
      {
        &quot;name&quot;: &quot;crossbeam-channel&quot;,
        &quot;version&quot;: &quot;0.5.4&quot;,
        &quot;msrv&quot;: &quot;1.36.0&quot;,
        &quot;dependencies&quot;: [
          &quot;cfg-if&quot;,
          &quot;crossbeam-utils&quot;,
          &quot;num_cpus&quot;,
          &quot;rand&quot;,
          &quot;signal-hook&quot;
        ]
      }
    ]
  }
}
</code></pre>
<p>Formatted:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;list&quot;,
  &quot;result&quot;: {
    &quot;variant&quot;: &quot;direct-deps&quot;,
    &quot;list&quot;: [
      {
        &quot;name&quot;: &quot;crossbeam-channel&quot;,
        &quot;version&quot;: &quot;0.5.4&quot;,
        &quot;msrv&quot;: &quot;1.36.0&quot;,
        &quot;dependencies&quot;: [
          &quot;cfg-if&quot;,
          &quot;crossbeam-utils&quot;,
          &quot;num_cpus&quot;,
          &quot;rand&quot;,
          &quot;signal-hook&quot;
        ]
      }
    ]
  }
}
</code></pre>
<p><strong>example 3: list with ordered-by-msrv</strong></p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;list&quot;,
  &quot;result&quot;: {
    &quot;variant&quot;: &quot;ordered-by-msrv&quot;,
    &quot;list&quot;: [
      {
        &quot;msrv&quot;: &quot;1.38.0&quot;,
        &quot;dependencies&quot;: [
          &quot;storyteller&quot;
        ]
      },
      {
        &quot;msrv&quot;: &quot;1.36.0&quot;,
        &quot;dependencies&quot;: [
          &quot;crossbeam-channel&quot;,
          &quot;crossbeam-utils&quot;
        ]
      },
      {
        &quot;msrv&quot;: null,
        &quot;dependencies&quot;: [
          &quot;cfg-if&quot;,
          &quot;lazy_static&quot;
        ]
      }
    ]
  }
}
</code></pre>
<p>Formatted:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;list&quot;,
  &quot;result&quot;: {
    &quot;variant&quot;: &quot;ordered-by-msrv&quot;,
    &quot;list&quot;: [
      {
        &quot;msrv&quot;: &quot;1.38.0&quot;,
        &quot;dependencies&quot;: [
          &quot;storyteller&quot;
        ]
      },
      {
        &quot;msrv&quot;: &quot;1.36.0&quot;,
        &quot;dependencies&quot;: [
          &quot;crossbeam-channel&quot;,
          &quot;crossbeam-utils&quot;
        ]
      },
      {
        &quot;msrv&quot;: null,
        &quot;dependencies&quot;: [
          &quot;cfg-if&quot;,
          &quot;lazy_static&quot;
        ]
      }
    ]
  }
}
</code></pre>
<p><strong>example 5: set</strong>:</p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;set&quot;,
  &quot;result&quot;: {
    &quot;version&quot;: &quot;1.38.0&quot;,
    &quot;manifest_path&quot;: &quot;..\\air3\\Cargo.toml&quot;
  }
}
</code></pre>
<p><strong>example 6: show</strong>:</p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;show&quot;,
  &quot;result&quot;: {
    &quot;version&quot;: &quot;1.38.0&quot;,
    &quot;manifest_path&quot;: &quot;..\\air3\\Cargo.toml&quot;
  }
}
</code></pre>
<p><strong>example 7: verify</strong>:</p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;subcommand_result&quot;,
  &quot;subcommand_id&quot;: &quot;verify&quot;,
  &quot;result&quot;: {
    &quot;toolchain&quot;: {
      &quot;version&quot;: &quot;1.38.0&quot;,
      &quot;target&quot;: &quot;x86_64-pc-windows-msvc&quot;
    },
    &quot;is_compatible&quot;: true
  }
}
</code></pre>
<h2 id="event-terminatewithfailure"><a class="header" href="#event-terminatewithfailure">Event: <code>TerminateWithFailure</code></a></h2>
<p><strong>type:</strong> terminate_with_failure</p>
<p><strong>description:</strong> Reports about failure which led to program termination with a non-zero exit code.</p>
<p><strong>fields:</strong></p>
<table><thead><tr><th>name</th><th>optional</th><th>description</th></tr></thead><tbody>
<tr><td>reason</td><td>no</td><td>Reason of failure</td></tr>
<tr><td>reason.description</td><td>no</td><td>Describes why cargo-msrv will terminate with a non-zero exit code</td></tr>
</tbody></table>
<p><strong>example:</strong></p>
<pre><code class="language-json lines">{
  &quot;type&quot;: &quot;terminate_with_failure&quot;,
  &quot;reason&quot;: {
    &quot;description&quot;: &quot;MSRV was not specified in Cargo manifest at '..\\air\\Cargo.toml'&quot;
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-format-minimal"><a class="header" href="#output-format-minimal">Output format: minimal</a></h1>
<p>The purpose of the <code>minimal</code> output format option is to provide just enough output for a machine (or shell script!)
to be understandable, while not requiring elaborate parsers like the <code>json</code> output format. It may also be used as
a minimal human-readable format.</p>
<p>This output format can be summarized by the following two statements:</p>
<ul>
<li>If the command was successful, it prints the commands final result and exits with a zero exit code. Output is printed
to <code>stdout</code>.</li>
<li>If the command was unsuccessful, it prints an error message, and exits with a non-zero exit code. Output is printed<br />
to <code>stderr</code>.</li>
</ul>
<p>You may also refer to the 🚧 TODO 🚧 section to determine which kind of errors result in a non-zero
exit code, and how different errors are categorised.</p>
<h1 id="output-by-subcommand-1"><a class="header" href="#output-by-subcommand-1">Output by subcommand</a></h1>
<h2 id="cargo-msrv-find-1"><a class="header" href="#cargo-msrv-find-1"># cargo msrv (find)</a></h2>
<p>If the MSRV was found, we report this minimal supported Rust version by writing it to <code>stdout</code>.
If it could not be found, we report <code>none</code> instead, and write this value to <code>stderr</code>.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example 1</a></h3>
<p>If the MSRV is <code>1.60.0</code>, the output will be just <code>1.60.0</code>.</p>
<pre><code class="language-shell">$ cargo msrv find --output-format minimal
# stdout
1.60.0
</code></pre>
<h3 id="example-2"><a class="header" href="#example-2">Example 2</a></h3>
<p>If the MSRV can't be found, for example if your project requires a nightly compiler feature
or has incorrect syntax, the output will be <code>none</code>.</p>
<pre><code class="language-shell">$ cargo msrv find --output-format minimal
# stderr
none
</code></pre>
<h2 id="cargo-msrv-list-1"><a class="header" href="#cargo-msrv-list-1"># cargo msrv list</a></h2>
<p>The <code>list</code> subcommand is not supported by the <code>minimal</code> output format, and &quot;unsupported&quot; will be printed.
Support may be added in the future.</p>
<h2 id="cargo-msrv-set-1"><a class="header" href="#cargo-msrv-set-1"># cargo msrv set</a></h2>
<p>The <code>set</code> subcommand prints the version set as MSRV.</p>
<h3 id="example-1-1"><a class="header" href="#example-1-1">Example 1</a></h3>
<p>If we set our MSRV to be <code>1.31</code>, the output will be <code>1.31</code>.</p>
<pre><code class="language-shell">cargo msrv find --output-format minimal set 1.31
# stdout
1.31
</code></pre>
<h2 id="cargo-msrv-show-1"><a class="header" href="#cargo-msrv-show-1"># cargo msrv show</a></h2>
<p>The <code>show</code> subcommand prints the detected MSRV, if specified in the Cargo Manifest.</p>
<h3 id="example-1-2"><a class="header" href="#example-1-2">Example 1</a></h3>
<p>Assuming our Cargo manifest contains a <code>1.60</code> MSRV, <code>cargo-msrv</code> will print <code>1.60</code>.</p>
<p><strong>Cargo.toml</strong></p>
<pre><code class="language-toml">[package]
rust-version = &quot;1.60&quot;
</code></pre>
<p><strong>Shell</strong></p>
<pre><code class="language-shell">$ cargo msrv find --output-format minimal show
# stdout
1.60
</code></pre>
<h3 id="example-2-1"><a class="header" href="#example-2-1">Example 2</a></h3>
<p>Assuming our Cargo manifest lists the MSRV in the <code>package.metadata.msrv</code> field, <code>cargo-msrv</code> will print <code>1.21.0</code>.
The <code>package.rust-version</code> field has precedence over the <code>package.metadata.msrv</code>. You may see the
<code>package.metadata.msrv</code>
key for crates which use a Cargo version which does not yet support the <code>package.rust-version</code> field. <code>cargo-msrv</code>
supports both fields.</p>
<p><strong>Cargo.toml</strong></p>
<pre><code class="language-toml">[package.metadata]
msrv = &quot;1.21.0&quot;
</code></pre>
<p><strong>Shell</strong></p>
<pre><code class="language-shell">$ cargo msrv find --output-format minimal show
# stdout
1.21.0
</code></pre>
<h2 id="cargo-msrv-verify-1"><a class="header" href="#cargo-msrv-verify-1"># cargo msrv verify</a></h2>
<p>The <code>verify</code> subcommand prints <code>true</code> (to stdout) with exit code zero if checking the toolchain for this platform which
matches the MSRV succeeds. Else, it prints <code>false</code> (to stderr) with an exit code which is non-zero.</p>
<h3 id="example-1-3"><a class="header" href="#example-1-3">Example 1</a></h3>
<p>Assuming our Cargo manifest contains an MSRV definition in the <code>package.rust-version</code> or <code>package.metadata.msrv</code> field,
and the compatibility check succeeds:</p>
<pre><code class="language-toml">[package.metadata]
msrv = &quot;1.31&quot;
</code></pre>
<p><strong>Shell</strong></p>
<pre><code class="language-shell">$ cargo msrv find --output-format minimal verify
# stdout
true
</code></pre>
<h3 id="example-2-2"><a class="header" href="#example-2-2">Example 2</a></h3>
<p>Assuming the given crate is incompatibility with the given MSRV:</p>
<p><strong>Shell</strong></p>
<pre><code class="language-shell">$ cargo msrv find --output-format minimal verify --rust-version 1.31
# stderr
false
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-format-no-user-output"><a class="header" href="#output-format-no-user-output">Output format: no-user-output</a></h1>
<p>The 'no-user-output' is not really a &quot;user output&quot; variant. Choosing this option disables user output of events
altogether. Disabling the user output may be achieved by providing the <code>--no-user-output</code> flag.</p>
<div style="break-before: page; page-break-before: always;"></div><p>🚧 Section is work-in-progress.</p>
<h1 id="-cargo-msrv-commands"><a class="header" href="#-cargo-msrv-commands">🕹️ cargo-msrv commands</a></h1>
<ul>
<li><a href="commands/./find.html">cargo-msrv find</a>: The <code>find</code> subcommand is used to find the MSRV for your crate.</li>
<li><a href="commands/./help.html">cargo-msrv help</a>: The <code>help</code> subcommand is used to learn more about the usage and the knobs and handles of
the application.</li>
<li><a href="commands/./list.html">cargo-msrv list</a>: The <code>list</code> subcommand is used to list the known MSRV's of the dependencies of your
crate.</li>
<li><a href="commands/./set.html">cargo-msrv set</a>: The <code>set</code> subcommand is used to quickly set the MSRV of a crate.</li>
<li><a href="commands/./show.html">cargo-msrv show</a>: The <code>show</code> subcommand is used to quickly show the MSRV of a crate.</li>
<li><a href="commands/./verify.html">cargo-msrv verify</a>: The <code>verify</code> subcommand is used to check whether the pinned MSRV is acceptable.</li>
</ul>
<h1 id="program-wide-options"><a class="header" href="#program-wide-options">Program wide options</a></h1>
<p>See <code>cargo msrv --help</code> for a full list of program wide options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-msrv"><a class="header" href="#cargo-msrv">cargo-msrv</a></h1>
<h1 id="command"><a class="header" href="#command">COMMAND</a></h1>
<ul>
<li>Standalone: <code>cargo-msrv find [options]</code></li>
<li>Through Cargo: <code>cargo msrv find [options]</code></li>
</ul>
<h1 id="preview"><a class="header" href="#preview">PREVIEW</a></h1>
<p><a href="https://asciinema.org/a/679855"><img src="https://asciinema.org/a/679855.svg" alt="asciicast" /></a></p>
<h1 id="description"><a class="header" href="#description">DESCRIPTION</a></h1>
<p>Find the MSRV for your project.</p>
<p>This command will test your project by running various Rust toolchains against your project. The order in which these
toolchains will be tested, and the amount of tests ran, depends on the search strategy, the amount of toolchains
available and of course the limiting factor of the project which will determine the MSRV. We usually call each test a
cargo-msrv <em>check</em>. By default, the check command, the command used to test whether toolchain passes or fails a check,
is <code>cargo check</code>.</p>
<p>There are currently two search strategies: <em>bisect</em> (default) and <em>linear</em>. Linear tests projects against toolchains in
a
most-recent to least-recent order. When a check fails, the previous Rust (if any) version is returned as the MSRV (i.e.
the highest still
toolchain for which a check command passes). Bisect tests projects using a binary search. This can be significantly
faster,
so it's usually advisable to enable it by default.</p>
<h2 id="why-run-against-complete-toolchains"><a class="header" href="#why-run-against-complete-toolchains">Why run against complete toolchains?</a></h2>
<p>Running against a complete toolchain may seem like a lot of wasted computing power. Why not run against just the AST,
and
(conditionally) tag each AST node with a supported from version (or query it, as library functions already have an '
available
from' Rust version)?</p>
<p>Earlier we developed a prototype to do exactly this, and we may still add it as an optional strategy in the future,
however
we found that the selection of the MSRV of a toolchain is not just limited by the source code itself. External factors
such as Rust editions or knobs in the Cargo manifest also impact the MSRV for a crate. As such, the running a complete
toolchain helps us to be more precise<sup>1</sup>.</p>
<h2 id="future-work"><a class="header" href="#future-work">Future work</a></h2>
<p><em>1. We want to eventually add a combination-of-strategies strategy which can combine result of other strategies to come
to a possibly more precise definition.</em></p>
<p><em>2. If you come up with a strategy which will add value to cargo-msrv, feel free to contribute the idea, or even an
implementation. If you don't know where to start, create a new issue, we're happy to help!</em></p>
<h1 id="options"><a class="header" href="#options">OPTIONS</a></h1>
<p><strong><code>--bisect</code></strong></p>
<p>Use a binary search to find the MSRV. This is usually faster than using a linear search.
The binary search strategy is the default since <code>cargo-msrv v0.14.0</code>.</p>
<p><strong><code>--linear</code></strong></p>
<p>Use a linear search to find the MSRV, by checking toolchains from latest to earliest.
The linear search strategy was the default prior to <code>cargo-msrv v0.14.0</code>.</p>
<p><strong><code>-h, --help</code></strong></p>
<p>Prints help information</p>
<p><strong><code>--include-all-patch-releases</code></strong></p>
<p>Include all patch releases, instead of only the last. By default, after the list of Rust releases has been fetched, we<br />
only keep the highest minor version for each Rust release. Say the list of Rust releases would be
<code>[&quot;1.31.1&quot;, &quot;1.31.0&quot;, &quot;1.30.0]</code>,
then we discard Rust <code>1.31.0</code>, as you would usually not depend on the non-bugfixed compiler releases, and the patch
version
does not contain new features, thus no features to impact the MSRV. When you provide this flag however, these additional
patch versions will be included in the search space.</p>
<p><strong><code>--ignore-lockfile</code></strong></p>
<p>Temporarily (re)moves the lockfile, so it will not interfere with the building process. This is important when
testing against Rust versions prior to 1.38.0, for which Cargo does not recognize the new v2 lockfile (<code>Cargo.lock</code>),
or some crates which use the even newer v3 lockfile.</p>
<p><strong><code>--log-level</code> level</strong></p>
<p>Specify the severity of debug logs which the program will write to the log output.
Possible values are: <code>error</code>, <code>warn</code>, <code>info</code> (default), <code>debug</code> and <code>trace</code>.
Lower severities include messages of higher severities.
When <code>--no-log</code> is present, this option will be ignored.</p>
<p><strong><code>--log-target</code> log_target</strong></p>
<p>Specify where cargo-msrv should output its internal debug logs.
Possible values are <code>file</code> (default) and <code>stdout</code>.
The log output of <code>stdout</code> may interfere with user output. We would suggest to use <code>--no-user-output</code> in tandem
with <code>--log-target stdout</code>. When <code>--no-log</code> is present, this option will be ignored.</p>
<p><strong><code>--max</code> version</strong></p>
<p>Latest (most recent) version to take into account. The version must match a valid three component Rust toolchain
version,
and be semver compatible. An example of an acceptable versions is &quot;1.35.0&quot;, while &quot;1.35&quot;, &quot;^1.35.0&quot; and &quot;1.35.0-beta&quot;
are not valid.</p>
<p><strong><code>--min</code> version</strong></p>
<p>Earliest (least recent) version to take into account. The version must match a valid three component Rust toolchain
version,
and be semver compatible. Edition aliases may also be used. An example of an acceptable versions is &quot;1.35.0&quot;, while
&quot;1.35&quot;, &quot;^1.35.0&quot; and &quot;1.35.0-beta&quot; are not valid. Editions map to the first version in which they were introduced, so
for example &quot;1.56.0&quot; for edition &quot;2021&quot;.</p>
<p><strong><code>--no-check-feedback</code></strong></p>
<p>If provided, the outcome of individual checks will not be printed. These prints provide feedback, about the order in
which
checks ran, and their results. This is especially useful if you want to know why a certain Rust version was deemed to be
incompatible, for example, so you can identify Rust features which require a certain minimum Rust version.</p>
<p><strong><code>--no-log</code></strong></p>
<p>Do not write (internal) debug log output to the log target.</p>
<p><strong><code>--no-user-output</code></strong></p>
<p>Disables printing of diagnostic status messages. Useful when internal log output messages are printed to the stdout,
using <code>--log-target stdout</code>, so no clipping between the user output prints and log message prints will take place.
When present, the <code>--output-format [value]</code> option will be ignored.</p>
<p><strong><code>--output-format</code> format</strong></p>
<p>Output diagnostic status messages in machine-readable format. Machine-readable status updates will be printed in the
requested format to stdout. The only accepted format is currently &quot;json&quot;, which will print diagnostic messages in a JSON
format. When this option is absent, human-readable output will be printed. Diagnostic messages can be disabled entirely
using the <code>--no-user-output</code> flag.</p>
<p><strong><code>--release-source</code> source</strong></p>
<p>Select the rust-releases source to use as the release index. Available options are <code>rust-changelog</code> and <code>rust-dist</code>.
The first will parse the Rust changelog file to determine which Rust releases have been made, while the second will
index
the Rust S3 distribution bucket.</p>
<p><strong><code>--path</code> directory-path</strong></p>
<p>Path to the cargo project directory. This directory should contain a Cargo manifest (i.e. <code>Cargo.toml</code>) file. The given
path should end in the Cargo manifest file. A valid path would be <code>/home/user/project</code>. A path like
<code>/home/user/project/Cargo.toml</code>
is incorrect.</p>
<p><strong><code>--target</code> target</strong></p>
<p>Supply a custom target triplet to use as Rust distribution. If absent, the rustup default toolchain is used.</p>
<p><strong><code>--write-toolchain-file</code></strong></p>
<p>Output a rust-toolchain file with the determined MSRV as toolchain. The toolchain file will pin the Rust version for
this crate.
See <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file">here</a> for more about the toolchain-file.</p>
<p><strong><code>-V, --version</code></strong></p>
<p>Prints cargo-msrv version information</p>
<p><strong><code>--</code> ...cmd</strong></p>
<p>When provided, the trailing command (<code>cmd</code>) will be used as the <em>cargo-msrv check</em> command, instead of the default
<code>cargo check</code>. This <code>cmd</code> must be runnable by <code>rustup</code> through <code>rustup run &lt;toolchain&gt; &lt;cmd&gt;</code>.</p>
<h1 id="examples"><a class="header" href="#examples">EXAMPLES</a></h1>
<ol>
<li>Try to determine the MSRV for the crate in your current working directory, using the binary search strategy.</li>
</ol>
<pre><code class="language-shell">cargo msrv find --bisect
</code></pre>
<p>or (from cargo-msrv <code>v0.14.0</code>, <code>bisect</code> is the default search method):</p>
<pre><code class="language-shell">cargo msrv find
</code></pre>
<ol start="2">
<li>Try to determine the MSRV for the crate in your current working directory, using the linear search strategy.</li>
</ol>
<pre><code class="language-shell">cargo msrv find --linear
</code></pre>
<p>NB: Prior to cargo-msrv <code>v0.14.0</code>, <code>linear</code> was the default search strategy, and no flag was available explicitly
use this search strategy.</p>
<ol start="3">
<li>Try to determine the MSRV for the crate in your current working directory, using a custom cargo-msrv check command:
<code>cargo test</code>.</li>
</ol>
<pre><code class="language-shell">cargo msrv find -- cargo test
</code></pre>
<ol start="4">
<li>Determine the MSRV for the crate in your current working directory, while ignoring <code>rust-version</code> fields in crates.</li>
</ol>
<pre><code class="language-shell">cargo msrv find -- cargo check --ignore-rust-version
</code></pre>
<p>Only available on Rust &gt;= 1.56.</p>
<ol start="5">
<li>Try to determine the MSRV for the crate in your current working directory, but use the JSON machine-readable output
format.</li>
</ol>
<pre><code class="language-shell">cargo msrv find --output-format json
</code></pre>
<h1 id="footnotes"><a class="header" href="#footnotes">FOOTNOTES</a></h1>
<p><sup>1</sup> Precision is of course a debatable concept. In this case we note that &quot;a toolchain must be able
to pass the cargo-msrv compatibility check command for a crate&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-msrv-help"><a class="header" href="#cargo-msrv-help">cargo-msrv help</a></h1>
<h1 id="command-1"><a class="header" href="#command-1">COMMAND</a></h1>
<ul>
<li>Standalone: <code>cargo-msrv help [subcommand]</code></li>
<li>Through Cargo: <code>cargo msrv help [subcommand]</code></li>
</ul>
<h1 id="preview-1"><a class="header" href="#preview-1">PREVIEW</a></h1>
<p><a href="https://asciinema.org/a/lBKWtUonNo4lP9f5ecQHh36ss"><img src="https://asciinema.org/a/lBKWtUonNo4lP9f5ecQHh36ss.svg" alt="asciicast" /></a></p>
<h1 id="description-1"><a class="header" href="#description-1">DESCRIPTION</a></h1>
<p>Help users navigate the cargo-msrv CLI by printing a help message.</p>
<!-- # OPTIONS -->
<h1 id="examples-1"><a class="header" href="#examples-1">EXAMPLES</a></h1>
<ol>
<li>Get help for cargo-msrv</li>
</ol>
<pre><code class="language-shell">cargo msrv help # OR cargo msrv --help
</code></pre>
<ol start="2">
<li>Get help for a cargo-msrv subcommand, for example <code>list</code>:</li>
</ol>
<pre><code class="language-shell">cargo msrv help list # OR cargo msrv list --help
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-msrv-list-2"><a class="header" href="#cargo-msrv-list-2">cargo-msrv list</a></h1>
<h1 id="command-2"><a class="header" href="#command-2">COMMAND</a></h1>
<ul>
<li>Standalone: <code>cargo-msrv list [options]</code></li>
<li>Through Cargo: <code>cargo msrv list [options]</code></li>
</ul>
<h1 id="preview-2"><a class="header" href="#preview-2">PREVIEW</a></h1>
<p><a href="https://asciinema.org/a/679857"><img src="https://asciinema.org/a/679857.svg" alt="asciicast" /></a></p>
<h1 id="description-2"><a class="header" href="#description-2">DESCRIPTION</a></h1>
<p>List the author specified MSRV for each depended-upon package.</p>
<p>Authors may specify the MSRV for their crate by adding the <code>package.rust-version</code> key to the <code>Cargo.toml</code> manifest.
See the <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field">Cargo book</a> for more. This
value is supported from Rust 1.56 onwards.</p>
<pre><code class="language-toml">[package]
rust-version = &quot;1.56&quot;
</code></pre>
<p>For crates which have an MSRV prior to Rust 1.56, you can use the <code>package.metadata.msrv</code> key in the <code>Cargo.toml</code>
manifest
instead. The <code>package.metadata</code> table exists specifically for tools like cargo-msrv, and within this table,
Cargo will not warn about keys it does not understand. Note that the use of this key is tailored to cargo-msrv and may
not be supported by other tools.</p>
<pre><code class="language-toml">[package.metadata]
msrv = &quot;1.53.0&quot;
</code></pre>
<p>Both <code>package.rust-version</code> and <code>package.metadata.msrv</code> require a two or three component version number, without semver
operators
or pre-release identifiers. For example, <code>1.56</code> and <code>1.56.0</code> are both valid, while <code>^1.56.0</code> and <code>1.56.0-beta</code> are not.</p>
<h1 id="options-1"><a class="header" href="#options-1">OPTIONS</a></h1>
<p><strong><code>--variant</code> variant</strong></p>
<p>Type of table to print.</p>
<p>The <code>variant</code> must be one of: <code>ordered-by-msrv</code> (default) or <code>direct-deps</code>.</p>
<p>When the <code>variant</code> is <code>ordered-by-msrv</code>, the program will print a table which lists the MSRV for both
direct and transitive dependencies. The table is sorted by MSRV. When a crate author did not specify an MSRV yet, the
cell in the MSRV row will be empty.</p>
<p>When the <code>variant</code> is <code>direct-deps</code>, the program will print a table which lists the following properties for each
direct-dependency of the given crate: the name of the dependency, the version of the dependency, the MSRV (empty if not
specified), it's dependencies.</p>
<h1 id="examples-2"><a class="header" href="#examples-2">EXAMPLES</a></h1>
<ol>
<li>List the MSRV's for both direct and transitive dependencies, grouped by MSRV.</li>
</ol>
<pre><code class="language-shell">cargo msrv list
</code></pre>
<p>Output for cargo-msrv commit c76b45a7ae39b52294e303eca6da56fda45b3feb:</p>
<pre><code class="language-text">Fetching index
┌────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ MSRV   ┆ Dependency                                                                                                                                │
╞════════╪═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╡
│        ┆ typed-builder, tracing-subscriber, tracing-appender, tracing, toml_edit, petgraph, once_cell, json, indicatif, dirs, console,             │
│        ┆ comfy-table, clap, cargo_metadata, tracing-serde, tracing-log, tracing-core, thread_local, smallvec, sharded-slab, serde_json, serde,     │
│        ┆ ansi_term, time, crossbeam-channel, tracing-attributes, pin-project-lite, cfg-if, kstring, itertools, indexmap, combine,                  │
│        ┆ rust-releases-rust-dist, rust-releases-rust-changelog, rust-releases-core, fixedbitset, regex, number_prefix, lazy_static, dirs-sys,      │
│        ┆ winapi, unicode-width, terminal_size, libc, encode_unicode, strum_macros, strum, crossterm, vec_map, textwrap, strsim, bitflags, atty,    │
│        ┆ ansi_term, semver, cargo-platform, camino, unicode-xid, log, ryu, itoa, serde_derive, crossbeam-utils, either, hashbrown, autocfg,        │
│        ┆ memchr, bytes, tokio, rust-releases-io, rusoto_s3, rusoto_core, chrono, regex-syntax, aho-corasick, redox_users,                          │
│        ┆ winapi-x86_64-pc-windows-gnu, winapi-i686-pc-windows-gnu, heck, signal-hook-mio, signal-hook, parking_lot, mio, crossterm_winapi,         │
│        ┆ hermit-abi, tokio-macros, signal-hook-registry, num_cpus, directories-next, attohttpc, xml-rs, futures, async-trait, rustc_version,       │
│        ┆ rusoto_signature, rusoto_credential, hyper-tls, hyper, http, crc32fast, base64, time, num-traits, num-integer, redox_syscall, getrandom,  │
│        ┆ unicode-segmentation, parking_lot_core, lock_api, instant, ntapi, miow, dirs-sys-next, wildmatch, url, openssl, native-tls, flate2,       │
│        ┆ futures-util, futures-task, futures-sink, futures-io, futures-executor, futures-core, futures-channel, semver, time, sha2,                │
│        ┆ percent-encoding, md5, hmac, hex, zeroize, shlex, dirs-next, tokio-native-tls, want, tower-service, socket2, httpdate, httparse,          │
│        ┆ http-body, fnv, wasi, scopeguard, matches, idna, form_urlencoded, openssl-sys, foreign-types, tempfile, security-framework-sys,           │
│        ┆ security-framework, schannel, openssl-probe, miniz_oxide, slab, proc-macro-nested, proc-macro-hack, pin-utils, futures-macro,             │
│        ┆ semver-parser, version_check, time-macros, stdweb, standback, const_fn, opaque-debug, digest, cpufeatures, block-buffer, crypto-mac,      │
│        ┆ try-lock, unicode-normalization, unicode-bidi, vcpkg, pkg-config, cc, foreign-types-shared, remove_dir_all, rand, core-foundation-sys,    │
│        ┆ core-foundation, adler, time-macros-impl, wasm-bindgen, stdweb-internal-runtime, stdweb-internal-macros, stdweb-derive, discard,          │
│        ┆ generic-array, subtle, tinyvec, rand_hc, rand_core, rand_chacha, wasm-bindgen-macro, sha1, base-x, typenum, tinyvec_macros, ppv-lite86,   │
│        ┆ wasm-bindgen-macro-support, wasm-bindgen-shared, wasm-bindgen-backend, bumpalo                                                            │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1.31.0 ┆ syn, quote, proc-macro2, thiserror, thiserror-impl                                                                                        │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1.51.0 ┆ rust-releases                                                                                                                             │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1.53.0 ┆ cargo-msrv                                                                                                                                │
└────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

</code></pre>
<p>NB: The dependencies which are listed with an empty MSRV cell do not specify a MSRV yet. At the time of writing, most
dependencies in the cargo-msrv dependency tree did not have an MSRV defined.</p>
<ol start="2">
<li>List the MSRV's for your direct dependencies using</li>
</ol>
<pre><code class="language-shell">cargo msrv list --variant direct-deps
</code></pre>
<p>Output for cargo-msrv commit c76b45a7ae39b52294e303eca6da56fda45b3feb:</p>
<pre><code class="language-text">Fetching index
┌────────────────────┬─────────┬────────┬──────────────────────────────────────────────────────────────────────────────┐
│ Dependency         ┆ Version ┆ MSRV   ┆ Depends on                                                                   │
╞════════════════════╪═════════╪════════╪══════════════════════════════════════════════════════════════════════════════╡
│ typed-builder      ┆ 0.9.1   ┆        ┆ proc-macro2, quote, syn                                                      │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ tracing-subscriber ┆ 0.3.1   ┆        ┆ ansi_term, lazy_static, matchers, parking_lot, regex, serde, serde_json,     │
│                    ┆         ┆        ┆ sharded-slab, smallvec, thread_local, time, tracing, tracing-core,           │
│                    ┆         ┆        ┆ tracing-log, tracing-serde, criterion, log, regex, time, tokio, tracing,     │
│                    ┆         ┆        ┆ tracing-futures, tracing-log                                                 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ tracing-appender   ┆ 0.2.0   ┆        ┆ crossbeam-channel, time, tracing-subscriber, tempfile, time, tracing         │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ tracing            ┆ 0.1.29  ┆        ┆ cfg-if, log, pin-project-lite, tracing-attributes, tracing-core, criterion,  │
│                    ┆         ┆        ┆ futures, log, tokio, wasm-bindgen-test                                       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ toml_edit          ┆ 0.8.0   ┆        ┆ combine, indexmap, itertools, kstring, serde, criterion, pretty_assertions,  │
│                    ┆         ┆        ┆ serde_json, toml, toml-test-harness                                          │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ rust-releases      ┆ 0.16.1  ┆ 1.51.0 ┆ rust-releases-channel-manifests, rust-releases-core, rust-releases-io,       │
│                    ┆         ┆        ┆ rust-releases-rust-changelog, rust-releases-rust-dist,                       │
│                    ┆         ┆        ┆ rust-releases-rust-dist-with-cli, yare                                       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ petgraph           ┆ 0.6.0   ┆        ┆ fixedbitset, indexmap, quickcheck, serde, serde_derive, bincode, defmac,     │
│                    ┆         ┆        ┆ itertools, odds, rand                                                        │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ once_cell          ┆ 1.8.0   ┆        ┆ parking_lot, crossbeam-utils, lazy_static, regex                             │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ json               ┆ 0.12.4  ┆        ┆                                                                              │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ indicatif          ┆ 0.16.2  ┆        ┆ console, lazy_static, number_prefix, rayon, regex, unicode-segmentation,     │
│                    ┆         ┆        ┆ unicode-width, rand, tokio                                                   │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ dirs               ┆ 4.0.0   ┆        ┆ dirs-sys                                                                     │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ console            ┆ 0.15.0  ┆        ┆ libc, once_cell, regex, terminal_size, unicode-width, encode_unicode,        │
│                    ┆         ┆        ┆ winapi, winapi-util                                                          │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ comfy-table        ┆ 4.1.1   ┆        ┆ crossterm, strum, strum_macros, unicode-width, criterion, doc-comment,       │
│                    ┆         ┆        ┆ pretty_assertions, proptest                                                  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ clap               ┆ 2.33.3  ┆        ┆ atty, bitflags, clippy, strsim, term_size, textwrap, unicode-width, vec_map, │
│                    ┆         ┆        ┆ yaml-rust, lazy_static, regex, version-sync, ansi_term                       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ cargo_metadata     ┆ 0.14.1  ┆        ┆ camino, cargo-platform, derive_builder, semver, serde, serde_json            │
└────────────────────┴─────────┴────────┴──────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>NB: The dependencies which are listed with an empty MSRV cell do not specify a MSRV yet. At the time of writing, most
dependencies in the cargo-msrv dependency tree did not have an MSRV defined.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-msrv-set-2"><a class="header" href="#cargo-msrv-set-2">cargo-msrv set</a></h1>
<h1 id="command-3"><a class="header" href="#command-3">COMMAND</a></h1>
<ul>
<li>Standalone: <code>cargo-msrv set</code></li>
<li>Through Cargo: <code>cargo msrv set</code></li>
</ul>
<h1 id="preview-3"><a class="header" href="#preview-3">PREVIEW</a></h1>
<p><a href="https://asciinema.org/a/679858"><img src="https://asciinema.org/a/679858.svg" alt="asciicast" /></a></p>
<h1 id="description-3"><a class="header" href="#description-3">DESCRIPTION</a></h1>
<p>Set the MSRV in the Cargo manifest.</p>
<p>This is either the <code>package.rust-version</code> field or the <code>package.metadata.msrv</code> field in the Cargo manifest (
<code>Cargo.toml</code>).</p>
<!-- # OPTIONS -->
<h1 id="examples-3"><a class="header" href="#examples-3">EXAMPLES</a></h1>
<ol>
<li>Set an MSRV by providing a two component Rust version</li>
</ol>
<pre><code class="language-shell">cargo msrv set 1.56
</code></pre>
<ol start="2">
<li>Set an MSRV by providing a three component Rust version</li>
</ol>
<pre><code class="language-shell">cargo msrv set 1.58.1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-msrv-show-2"><a class="header" href="#cargo-msrv-show-2">cargo-msrv show</a></h1>
<h1 id="command-4"><a class="header" href="#command-4">COMMAND</a></h1>
<ul>
<li>Standalone: <code>cargo-msrv show</code></li>
<li>Through Cargo: <code>cargo msrv show</code></li>
</ul>
<h1 id="preview-4"><a class="header" href="#preview-4">PREVIEW</a></h1>
<p><a href="https://asciinema.org/a/679864"><img src="https://asciinema.org/a/679864.svg" alt="asciicast" /></a></p>
<h1 id="description-4"><a class="header" href="#description-4">DESCRIPTION</a></h1>
<p>Print the crate author specified MSRV.</p>
<p>This is either the <code>package.rust-version</code> field or the <code>package.metadata.msrv</code> field in the Cargo manifest (
<code>Cargo.toml</code>).</p>
<!-- # OPTIONS -->
<h1 id="examples-4"><a class="header" href="#examples-4">EXAMPLES</a></h1>
<ol>
<li>Show the MSRV specified by a crate author</li>
</ol>
<pre><code class="language-shell">cargo msrv show
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-msrv-verify-2"><a class="header" href="#cargo-msrv-verify-2">cargo-msrv verify</a></h1>
<h1 id="command-5"><a class="header" href="#command-5">COMMAND</a></h1>
<ul>
<li>Standalone: <code>cargo-msrv verify</code></li>
<li>Through Cargo: <code>cargo msrv verify</code></li>
</ul>
<h1 id="preview-5"><a class="header" href="#preview-5">PREVIEW</a></h1>
<p><a href="https://asciinema.org/a/679863"><img src="https://asciinema.org/a/679863.svg" alt="asciicast" /></a></p>
<h1 id="description-5"><a class="header" href="#description-5">DESCRIPTION</a></h1>
<p>Verify whether the MSRV can be satisfied.</p>
<p>The MSRV can be specified in the Cargo manifest (<code>Cargo.toml</code>) using either the <code>package.rust-version</code> (Rust &gt;=1.56,
recommended),
or the <code>package.metadata.msrv</code> field.</p>
<p>If the check fails, the program returns with a non-zero exit code.</p>
<h1 id="options-2"><a class="header" href="#options-2">OPTIONS</a></h1>
<p><strong><code>--rust-version</code> version</strong></p>
<p>Specify the Rust version of a Rust toolchain, against which the crate will be checked for compatibility.</p>
<h1 id="examples-5"><a class="header" href="#examples-5">EXAMPLES</a></h1>
<ol>
<li>Verify whether the MSRV specified in the Cargo manifest is satisfiable (Good case).</li>
</ol>
<p>Given a minimal rust crate with the following Cargo.toml manifest:</p>
<pre><code class="language-toml">[package]
name = &quot;example&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
rust-version = &quot;1.56.0&quot;
</code></pre>
<p>and this minimal lib.rs file:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello world&quot;);
}
</code></pre></pre>
<p>We check whether the MSRV's check command, in this case the default <code>cargo check</code>, can be satisfied.
The crate author specified the MSRV in the Cargo.toml, using the <code>package.rust-version</code> key.
Since the example crate used no features requiring a more recent version than Rust 1.56, the check will be satisfied,
and the program returns a with exit code 0 (success).</p>
<pre><code class="language-shell">cargo msrv verify # Will succeed, and return with exit code 0
</code></pre>
<ol start="2">
<li>Verify whether the MSRV specified in the Cargo manifest is satisfiable (Bad case).</li>
</ol>
<p>Given a minimal rust crate with the following Cargo.toml manifest:</p>
<pre><code class="language-toml">[package]
name = &quot;example&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
rust-version = &quot;1.56.0&quot;
</code></pre>
<p>and this minimal lib.rs file:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let cmd = Command::new(&quot;ls&quot;);
    assert_eq!(cmd.get_program(), &quot;ls&quot;); // will fail because Command::get_program was introduced in 1.57, which is greater than 1.56 (the MSRV)
}
</code></pre></pre>
<p>We check whether the MSRV's check command, in this case the default <code>cargo check</code>, can be satisfied.
The crate author specified the MSRV in the Cargo.toml, using the <code>package.rust-version</code> key.
Since the example crate used a feature requiring a more recent version than Rust 1.56, the check cannot be satisfied,
and the program returns a with a non-zero exit code (failure).</p>
<pre><code class="language-shell">cargo msrv verify # Will fail, and return a non-zero exit code
</code></pre>
<ol start="3">
<li>Run the 'verify' subcommand on a crate not in our current working directory.</li>
</ol>
<pre><code class="language-shell">cargo msrv --path path/to/my/crate verify
</code></pre>
<p>This example shows how to use arguments (in this case <code>--path</code>) shared between the default cargo-msrv command and
verify.
Note that shared arguments must be specified before the subcommand (here <code>verify</code>).</p>
<ol start="4">
<li>Run the 'verify' subcommand using a self-determined Rust version.</li>
</ol>
<pre><code class="language-shell">cargo msrv verify --rust-version 1.56
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verification-in-ci"><a class="header" href="#verification-in-ci">Verification in CI</a></h1>
<p>You can run <code>cargo msrv verify</code> in continuous integration services to check the
MSRV with every contribution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitlab-cicd"><a class="header" href="#gitlab-cicd">GitLab CI/CD</a></h1>
<p>Use this snippet to have a dedicated <a href="https://docs.gitlab.com/ee/ci/jobs/">job</a>
in the <a href="https://docs.gitlab.com/ee/ci/pipelines/">test stage of your pipeline</a>:</p>
<pre><code class="language-yml">msrv:
  stage: test
  image:
    name: foresterre/cargo-msrv:latest
    entrypoint: [&quot;&quot;]
  before_script:
    - rustc --version
    - cargo --version
    - cargo msrv --version
  script:
    - cargo msrv --output-format minimal verify
</code></pre>
<p><strong>Note:</strong> The empty <code>entrypoint</code> is necessary because the image has
<code>cargo-msrv</code> as its entrypoint. Since we want to run other commands, like
<code>cargo --version</code>, GitLab requires either an empty entrypoint or a shell.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
